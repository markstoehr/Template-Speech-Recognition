#
# Author: Mark Stoehr
#
#


##
#
# Generally handles the audio processing and labeling
#
#


import numpy as np
import os;
from scipy import linalg
from scipy.fftpack import fft
from scipy.signal import hanning
from scipy.signal import convolve
from scipy.ndimage.filters import generic_filter, correlate,correlate1d, median_filter, maximum_filter

dctm13_40 = np.array([[  1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01,   1.58113883e-01,   1.58113883e-01,
          1.58113883e-01],
       [  2.23434405e-01,   2.22056858e-01,   2.19310256e-01,
          2.15211533e-01,   2.09785960e-01,   2.03066987e-01,
          1.95096038e-01,   1.85922257e-01,   1.75602204e-01,
          1.64199505e-01,   1.51784461e-01,   1.38433616e-01,
          1.24229281e-01,   1.09259031e-01,   9.36151633e-02,
          7.73941268e-02,   6.06959298e-02,   4.36235222e-02,
          2.62821611e-02,   8.77876168e-03,  -8.77876168e-03,
         -2.62821611e-02,  -4.36235222e-02,  -6.06959298e-02,
         -7.73941268e-02,  -9.36151633e-02,  -1.09259031e-01,
         -1.24229281e-01,  -1.38433616e-01,  -1.51784461e-01,
         -1.64199505e-01,  -1.75602204e-01,  -1.85922257e-01,
         -1.95096038e-01,  -2.03066987e-01,  -2.09785960e-01,
         -2.15211533e-01,  -2.19310256e-01,  -2.22056858e-01,
         -2.23434405e-01],
       [  2.22917493e-01,   2.17428524e-01,   2.06585744e-01,
          1.90656137e-01,   1.70031943e-01,   1.45220998e-01,
          1.16834231e-01,   8.55706169e-02,   5.21999703e-02,
          1.75439872e-02,  -1.75439872e-02,  -5.21999703e-02,
         -8.55706169e-02,  -1.16834231e-01,  -1.45220998e-01,
         -1.70031943e-01,  -1.90656137e-01,  -2.06585744e-01,
         -2.17428524e-01,  -2.22917493e-01,  -2.22917493e-01,
         -2.17428524e-01,  -2.06585744e-01,  -1.90656137e-01,
         -1.70031943e-01,  -1.45220998e-01,  -1.16834231e-01,
         -8.55706169e-02,  -5.21999703e-02,  -1.75439872e-02,
          1.75439872e-02,   5.21999703e-02,   8.55706169e-02,
          1.16834231e-01,   1.45220998e-01,   1.70031943e-01,
          1.90656137e-01,   2.06585744e-01,   2.17428524e-01,
          2.22917493e-01],
       [  2.22056858e-01,   2.09785960e-01,   1.85922257e-01,
          1.51784461e-01,   1.09259031e-01,   6.06959298e-02,
          8.77876168e-03,  -4.36235222e-02,  -9.36151633e-02,
         -1.38433616e-01,  -1.75602204e-01,  -2.03066987e-01,
         -2.19310256e-01,  -2.23434405e-01,  -2.15211533e-01,
         -1.95096038e-01,  -1.64199505e-01,  -1.24229281e-01,
         -7.73941268e-02,  -2.62821611e-02,   2.62821611e-02,
          7.73941268e-02,   1.24229281e-01,   1.64199505e-01,
          1.95096038e-01,   2.15211533e-01,   2.23434405e-01,
          2.19310256e-01,   2.03066987e-01,   1.75602204e-01,
          1.38433616e-01,   9.36151633e-02,   4.36235222e-02,
         -8.77876168e-03,  -6.06959298e-02,  -1.09259031e-01,
         -1.51784461e-01,  -1.85922257e-01,  -2.09785960e-01,
         -2.22056858e-01],
       [  2.20853827e-01,   1.99235116e-01,   1.58113883e-01,
          1.01515362e-01,   3.49798098e-02,  -3.49798098e-02,
         -1.01515362e-01,  -1.58113883e-01,  -1.99235116e-01,
         -2.20853827e-01,  -2.20853827e-01,  -1.99235116e-01,
         -1.58113883e-01,  -1.01515362e-01,  -3.49798098e-02,
          3.49798098e-02,   1.01515362e-01,   1.58113883e-01,
          1.99235116e-01,   2.20853827e-01,   2.20853827e-01,
          1.99235116e-01,   1.58113883e-01,   1.01515362e-01,
          3.49798098e-02,  -3.49798098e-02,  -1.01515362e-01,
         -1.58113883e-01,  -1.99235116e-01,  -2.20853827e-01,
         -2.20853827e-01,  -1.99235116e-01,  -1.58113883e-01,
         -1.01515362e-01,  -3.49798098e-02,   3.49798098e-02,
          1.01515362e-01,   1.58113883e-01,   1.99235116e-01,
          2.20853827e-01],
       [  2.19310256e-01,   1.85922257e-01,   1.24229281e-01,
          4.36235222e-02,  -4.36235222e-02,  -1.24229281e-01,
         -1.85922257e-01,  -2.19310256e-01,  -2.19310256e-01,
         -1.85922257e-01,  -1.24229281e-01,  -4.36235222e-02,
          4.36235222e-02,   1.24229281e-01,   1.85922257e-01,
          2.19310256e-01,   2.19310256e-01,   1.85922257e-01,
          1.24229281e-01,   4.36235222e-02,  -4.36235222e-02,
         -1.24229281e-01,  -1.85922257e-01,  -2.19310256e-01,
         -2.19310256e-01,  -1.85922257e-01,  -1.24229281e-01,
         -4.36235222e-02,   4.36235222e-02,   1.24229281e-01,
          1.85922257e-01,   2.19310256e-01,   2.19310256e-01,
          1.85922257e-01,   1.24229281e-01,   4.36235222e-02,
         -4.36235222e-02,  -1.24229281e-01,  -1.85922257e-01,
         -2.19310256e-01],
       [  2.17428524e-01,   1.70031943e-01,   8.55706169e-02,
         -1.75439872e-02,  -1.16834231e-01,  -1.90656137e-01,
         -2.22917493e-01,  -2.06585744e-01,  -1.45220998e-01,
         -5.21999703e-02,   5.21999703e-02,   1.45220998e-01,
          2.06585744e-01,   2.22917493e-01,   1.90656137e-01,
          1.16834231e-01,   1.75439872e-02,  -8.55706169e-02,
         -1.70031943e-01,  -2.17428524e-01,  -2.17428524e-01,
         -1.70031943e-01,  -8.55706169e-02,   1.75439872e-02,
          1.16834231e-01,   1.90656137e-01,   2.22917493e-01,
          2.06585744e-01,   1.45220998e-01,   5.21999703e-02,
         -5.21999703e-02,  -1.45220998e-01,  -2.06585744e-01,
         -2.22917493e-01,  -1.90656137e-01,  -1.16834231e-01,
         -1.75439872e-02,   8.55706169e-02,   1.70031943e-01,
          2.17428524e-01],
       [  2.15211533e-01,   1.51784461e-01,   4.36235222e-02,
         -7.73941268e-02,  -1.75602204e-01,  -2.22056858e-01,
         -2.03066987e-01,  -1.24229281e-01,  -8.77876168e-03,
          1.09259031e-01,   1.95096038e-01,   2.23434405e-01,
          1.85922257e-01,   9.36151633e-02,  -2.62821611e-02,
         -1.38433616e-01,  -2.09785960e-01,  -2.19310256e-01,
         -1.64199505e-01,  -6.06959298e-02,   6.06959298e-02,
          1.64199505e-01,   2.19310256e-01,   2.09785960e-01,
          1.38433616e-01,   2.62821611e-02,  -9.36151633e-02,
         -1.85922257e-01,  -2.23434405e-01,  -1.95096038e-01,
         -1.09259031e-01,   8.77876168e-03,   1.24229281e-01,
          2.03066987e-01,   2.22056858e-01,   1.75602204e-01,
          7.73941268e-02,  -4.36235222e-02,  -1.51784461e-01,
         -2.15211533e-01],
       [  2.12662702e-01,   1.31432778e-01,   1.36919675e-17,
         -1.31432778e-01,  -2.12662702e-01,  -2.12662702e-01,
         -1.31432778e-01,  -4.10759024e-17,   1.31432778e-01,
          2.12662702e-01,   2.12662702e-01,   1.31432778e-01,
          6.84598373e-17,  -1.31432778e-01,  -2.12662702e-01,
         -2.12662702e-01,  -1.31432778e-01,  -9.58437722e-17,
          1.31432778e-01,   2.12662702e-01,   2.12662702e-01,
          1.31432778e-01,   1.23227707e-16,  -1.31432778e-01,
         -2.12662702e-01,  -2.12662702e-01,  -1.31432778e-01,
         -5.47817107e-16,   1.31432778e-01,   2.12662702e-01,
          2.12662702e-01,   1.31432778e-01,  -2.19209888e-16,
         -1.31432778e-01,  -2.12662702e-01,  -2.12662702e-01,
         -1.31432778e-01,  -6.02584976e-16,   1.31432778e-01,
          2.12662702e-01],
       [  2.09785960e-01,   1.09259031e-01,  -4.36235222e-02,
         -1.75602204e-01,  -2.23434405e-01,  -1.64199505e-01,
         -2.62821611e-02,   1.24229281e-01,   2.15211533e-01,
          2.03066987e-01,   9.36151633e-02,  -6.06959298e-02,
         -1.85922257e-01,  -2.22056858e-01,  -1.51784461e-01,
         -8.77876168e-03,   1.38433616e-01,   2.19310256e-01,
          1.95096038e-01,   7.73941268e-02,  -7.73941268e-02,
         -1.95096038e-01,  -2.19310256e-01,  -1.38433616e-01,
          8.77876168e-03,   1.51784461e-01,   2.22056858e-01,
          1.85922257e-01,   6.06959298e-02,  -9.36151633e-02,
         -2.03066987e-01,  -2.15211533e-01,  -1.24229281e-01,
          2.62821611e-02,   1.64199505e-01,   2.23434405e-01,
          1.75602204e-01,   4.36235222e-02,  -1.09259031e-01,
         -2.09785960e-01],
       [  2.06585744e-01,   8.55706169e-02,  -8.55706169e-02,
         -2.06585744e-01,  -2.06585744e-01,  -8.55706169e-02,
          8.55706169e-02,   2.06585744e-01,   2.06585744e-01,
          8.55706169e-02,  -8.55706169e-02,  -2.06585744e-01,
         -2.06585744e-01,  -8.55706169e-02,   8.55706169e-02,
          2.06585744e-01,   2.06585744e-01,   8.55706169e-02,
         -8.55706169e-02,  -2.06585744e-01,  -2.06585744e-01,
         -8.55706169e-02,   8.55706169e-02,   2.06585744e-01,
          2.06585744e-01,   8.55706169e-02,  -8.55706169e-02,
         -2.06585744e-01,  -2.06585744e-01,  -8.55706169e-02,
          8.55706169e-02,   2.06585744e-01,   2.06585744e-01,
          8.55706169e-02,  -8.55706169e-02,  -2.06585744e-01,
         -2.06585744e-01,  -8.55706169e-02,   8.55706169e-02,
          2.06585744e-01],
       [  2.03066987e-01,   6.06959298e-02,  -1.24229281e-01,
         -2.22056858e-01,  -1.64199505e-01,   8.77876168e-03,
          1.75602204e-01,   2.19310256e-01,   1.09259031e-01,
         -7.73941268e-02,  -2.09785960e-01,  -1.95096038e-01,
         -4.36235222e-02,   1.38433616e-01,   2.23434405e-01,
          1.51784461e-01,  -2.62821611e-02,  -1.85922257e-01,
         -2.15211533e-01,  -9.36151633e-02,   9.36151633e-02,
          2.15211533e-01,   1.85922257e-01,   2.62821611e-02,
         -1.51784461e-01,  -2.23434405e-01,  -1.38433616e-01,
          4.36235222e-02,   1.95096038e-01,   2.09785960e-01,
          7.73941268e-02,  -1.09259031e-01,  -2.19310256e-01,
         -1.75602204e-01,  -8.77876168e-03,   1.64199505e-01,
          2.22056858e-01,   1.24229281e-01,  -6.06959298e-02,
         -2.03066987e-01],[  1.99235116e-01,   3.49798098e-02,  -1.58113883e-01,
         -2.20853827e-01,  -1.01515362e-01,   1.01515362e-01,
          2.20853827e-01,   1.58113883e-01,  -3.49798098e-02,
         -1.99235116e-01,  -1.99235116e-01,  -3.49798098e-02,
          1.58113883e-01,   2.20853827e-01,   1.01515362e-01,
         -1.01515362e-01,  -2.20853827e-01,  -1.58113883e-01,
          3.49798098e-02,   1.99235116e-01,   1.99235116e-01,
          3.49798098e-02,  -1.58113883e-01,  -2.20853827e-01,
         -1.01515362e-01,   1.01515362e-01,   2.20853827e-01,
          1.58113883e-01,  -3.49798098e-02,  -1.99235116e-01,
         -1.99235116e-01,  -3.49798098e-02,   1.58113883e-01,
          2.20853827e-01,   1.01515362e-01,  -1.01515362e-01,
         -2.20853827e-01,  -1.58113883e-01,   3.49798098e-02,
          1.99235116e-01]])

E_slep160 = np.array([[0.00061049556,0.0041888209,0.018726333,0.059561861,0.13080983],[0.00081705134,0.0052223175,0.021780346,0.06488692,0.13431436],[0.0010561444,0.0063655113,0.024999421,0.070172781,0.13724155],[0.001330404,0.0076218102,0.02837497,0.075386477,0.13956553],[0.0016425045,0.0089941908,0.031897053,0.080494669,0.14126437],[0.0019951549,0.010485159,0.035554394,0.085463871,0.14232031],[0.0023910865,0.012096714,0.039334412,0.090260689,0.1427199],[0.0028330407,0.013830311,0.043223263,0.094852055,0.14245418],[0.0033237563,0.015686825,0.047205884,0.099205473,0.14151875],[0.003865955,0.017666527,0.051266056,0.10328925,0.13991387],[0.0044623282,0.019769047,0.055386468,0.10707275,0.13764448],[0.0051155216,0.021993352,0.0595488,0.1105266,0.13472022],[0.0058281208,0.024337724,0.063733807,0.11362296,0.13115534],[0.0066026353,0.026799738,0.06792141,0.1163357,0.12696873],[0.0074414838,0.029376248,0.072090805,0.11864065,0.1221837],[0.0083469776,0.032063375,0.076220569,0.12051576,0.11682792],[0.0093213054,0.034856497,0.080288779,0.12194136,0.11093321],[0.010366518,0.037750249,0.084273133,0.12290025,0.10453533],[0.01148451,0.040738518,0.088151083,0.12337791,0.097673751],[0.012677008,0.043814452,0.091899962,0.12336265,0.09039137],[0.013945554,0.04697047,0.095497126,0.12284569,0.082734215],[0.015291489,0.05019827,0.098920091,0.12182132,0.074751125],[0.01671594,0.053488852,0.10214668,0.12028694,0.066493395],[0.018219807,0.056832541,0.10515515,0.11824315,0.058014407],[0.019803747,0.060219012,0.10792437,0.11569379,0.049369245],[0.021468166,0.063637323,0.11043391,0.11264594,0.040614289],[0.023213202,0.067075952,0.11266425,0.10910993,0.031806804],[0.02503872,0.070522835,0.11459686,0.10509934,0.023004511],[0.026944296,0.073965412,0.11621434,0.10063089,0.014265163],[0.028929216,0.077390679,0.1175006,0.095724426,0.0056461116],[0.030992462,0.080785233,0.11844093,0.090402783,-0.0027961244],[0.033132706,0.084135335,0.11902212,0.084691695,-0.011006282],[0.035348312,0.087426962,0.11923263,0.07861964,-0.018930771],[0.037637323,0.090645877,0.11906261,0.072217682,-0.026518084],[0.039997466,0.093777686,0.11850404,0.065519296,-0.033719182],[0.042426146,0.09680791,0.11755082,0.058560163,-0.040487872],[0.04492045,0.099722053,0.1161988,0.051377955,-0.046781159],[0.047477149,0.10250567,0.1144459,0.044012103,-0.052559575],[0.050092698,0.10514444,0.1122921,0.036503548,-0.057787483],[0.052763247,0.10762425,0.10973952,0.028894484,-0.062433348],[0.055484642,0.10993123,0.10679243,0.02122808,-0.066469986],[0.058252436,0.11205189,0.10345724,0.013548207,-0.069874767],[0.061061898,0.11397313,0.099742556,0.0058991446,-0.072629798],[0.063908027,0.11568235,0.095659104,-0.0016747119,-0.074722057],[0.066785559,0.1171675,0.091219737,-0.0091291456,-0.076143494],[0.069688987,0.11841716,0.086439385,-0.016420418,-0.076891098],[0.072612573,0.11942061,0.081335001,-0.023505564,-0.07696692],[0.075550364,0.12016788,0.075925491,-0.030342688,-0.076378055],[0.078496215,0.12064984,0.070231636,-0.03689125,-0.075136592],[0.081443804,0.1208582,0.064276002,-0.043112344,-0.073259516],[0.084386653,0.12078565,0.058082829,-0.048968977,-0.070768579],[0.087318151,0.12042582,0.051677921,-0.054426322,-0.067690132],[0.090231574,0.11977339,0.045088518,-0.059451965,-0.064054917],[0.093120114,0.11882412,0.038343155,-0.06401614,-0.059897828],[0.095976894,0.11757485,0.031471524,-0.068091941,-0.05525764],[0.098795002,0.11602358,0.024504312,-0.071655518,-0.050176704],[0.10156751,0.11416946,0.017473047,-0.07468625,-0.044700616],[0.1042875,0.11201283,0.01040992,-0.077166904,-0.038877861],[0.10694809,0.10955523,0.0033476236,-0.079083762,-0.032759431],[0.10954247,0.1067994,-0.0036808377,-0.080426731,-0.026398425],[0.11206391,0.1037493,-0.010642321,-0.081189427,-0.019849634],[0.11450581,0.10041007,-0.017503733,-0.081369229,-0.013169108],[0.11686169,0.096788057,-0.024232212,-0.080967313,-0.0064137154],[0.11912526,0.0928908,-0.030795313,-0.079988661,0.00035930274],[0.1212904,0.088726975,-0.037161194,-0.078442034,0.0070927853],[0.12335122,0.084306391,-0.04329879,-0.076339933,0.013730101],[0.12530208,0.079639949,-0.049178,-0.073698519,0.020215593],[0.12713758,0.074739602,-0.05476985,-0.070537521,0.026495021],[0.12885262,0.069618311,-0.060046664,-0.066880109,0.032515987],[0.1304424,0.064289992,-0.064982227,-0.062752749,0.038228349],[0.13190246,0.058769461,-0.069551931,-0.05818503,0.043584618],[0.13322867,0.053072371,-0.073732919,-0.053209478,0.048540331],[0.13441726,0.04721515,-0.077504224,-0.047861335,0.053054405],[0.13546485,0.041214928,-0.080846883,-0.042178333,0.057089458],[0.13636844,0.035089466,-0.083744055,-0.036200442,0.060612109],[0.13712545,0.028857077,-0.086181116,-0.029969605,0.063593238],[0.13773369,0.022536549,-0.088145743,-0.02352946,0.066008218],[0.13819141,0.016147058,-0.089627993,-0.016925045,0.06783711],[0.13849729,0.0097080883,-0.090620355,-0.010202501,0.069064819],[0.13865045,0.0032393427,-0.091117798,-0.0034087621,0.069681216],[0.13865045,-0.0032393427,-0.091117798,0.0034087621,0.069681216],[0.13849729,-0.0097080883,-0.090620355,0.010202501,0.069064819],[0.13819141,-0.016147058,-0.089627993,0.016925045,0.06783711],[0.13773369,-0.022536549,-0.088145743,0.02352946,0.066008218],[0.13712545,-0.028857077,-0.086181116,0.029969605,0.063593238],[0.13636844,-0.035089466,-0.083744055,0.036200442,0.060612109],[0.13546485,-0.041214928,-0.080846883,0.042178333,0.057089458],[0.13441726,-0.04721515,-0.077504224,0.047861335,0.053054405],[0.13322867,-0.053072371,-0.073732919,0.053209478,0.048540331],[0.13190246,-0.058769461,-0.069551931,0.05818503,0.043584618],[0.1304424,-0.064289992,-0.064982227,0.062752749,0.038228349],[0.12885262,-0.069618311,-0.060046664,0.066880109,0.032515987],[0.12713758,-0.074739602,-0.05476985,0.070537521,0.026495021],[0.12530208,-0.079639949,-0.049178,0.073698519,0.020215593],[0.12335122,-0.084306391,-0.04329879,0.076339933,0.013730101],[0.1212904,-0.088726975,-0.037161194,0.078442034,0.0070927853],[0.11912526,-0.0928908,-0.030795313,0.079988661,0.00035930274],[0.11686169,-0.096788057,-0.024232212,0.080967313,-0.0064137154],[0.11450581,-0.10041007,-0.017503733,0.081369229,-0.013169108],[0.11206391,-0.1037493,-0.010642321,0.081189427,-0.019849634],[0.10954247,-0.1067994,-0.0036808377,0.080426731,-0.026398425],[0.10694809,-0.10955523,0.0033476236,0.079083762,-0.032759431],[0.1042875,-0.11201283,0.01040992,0.077166904,-0.038877861],[0.10156751,-0.11416946,0.017473047,0.07468625,-0.044700616],[0.098795002,-0.11602358,0.024504312,0.071655518,-0.050176704],[0.095976894,-0.11757485,0.031471524,0.068091941,-0.05525764],[0.093120114,-0.11882412,0.038343155,0.06401614,-0.059897828],[0.090231574,-0.11977339,0.045088518,0.059451965,-0.064054917],[0.087318151,-0.12042582,0.051677921,0.054426322,-0.067690132],[0.084386653,-0.12078565,0.058082829,0.048968977,-0.070768579],[0.081443804,-0.1208582,0.064276002,0.043112344,-0.073259516],[0.078496215,-0.12064984,0.070231636,0.03689125,-0.075136592],[0.075550364,-0.12016788,0.075925491,0.030342688,-0.076378055],[0.072612573,-0.11942061,0.081335001,0.023505564,-0.07696692],[0.069688987,-0.11841716,0.086439385,0.016420418,-0.076891098],[0.066785559,-0.1171675,0.091219737,0.0091291456,-0.076143494],[0.063908027,-0.11568235,0.095659104,0.0016747119,-0.074722057],[0.061061898,-0.11397313,0.099742556,-0.0058991446,-0.072629798],[0.058252436,-0.11205189,0.10345724,-0.013548207,-0.069874767],[0.055484642,-0.10993123,0.10679243,-0.02122808,-0.066469986],[0.052763247,-0.10762425,0.10973952,-0.028894484,-0.062433348],[0.050092698,-0.10514444,0.1122921,-0.036503548,-0.057787483],[0.047477149,-0.10250567,0.1144459,-0.044012103,-0.052559575],[0.04492045,-0.099722053,0.1161988,-0.051377955,-0.046781159],[0.042426146,-0.09680791,0.11755082,-0.058560163,-0.040487872],[0.039997466,-0.093777686,0.11850404,-0.065519296,-0.033719182],[0.037637323,-0.090645877,0.11906261,-0.072217682,-0.026518084],[0.035348312,-0.087426962,0.11923263,-0.07861964,-0.018930771],[0.033132706,-0.084135335,0.11902212,-0.084691695,-0.011006282],[0.030992462,-0.080785233,0.11844093,-0.090402783,-0.0027961244],[0.028929216,-0.077390679,0.1175006,-0.095724426,0.0056461116],[0.026944296,-0.073965412,0.11621434,-0.10063089,0.014265163],[0.02503872,-0.070522835,0.11459686,-0.10509934,0.023004511],[0.023213202,-0.067075952,0.11266425,-0.10910993,0.031806804],[0.021468166,-0.063637323,0.11043391,-0.11264594,0.040614289],[0.019803747,-0.060219012,0.10792437,-0.11569379,0.049369245],[0.018219807,-0.056832541,0.10515515,-0.11824315,0.058014407],[0.01671594,-0.053488852,0.10214668,-0.12028694,0.066493395],[0.015291489,-0.05019827,0.098920091,-0.12182132,0.074751125],[0.013945554,-0.04697047,0.095497126,-0.12284569,0.082734215],[0.012677008,-0.043814452,0.091899962,-0.12336265,0.09039137],[0.01148451,-0.040738518,0.088151083,-0.12337791,0.097673751],[0.010366518,-0.037750249,0.084273133,-0.12290025,0.10453533],[0.0093213054,-0.034856497,0.080288779,-0.12194136,0.11093321],[0.0083469776,-0.032063375,0.076220569,-0.12051576,0.11682792],[0.0074414838,-0.029376248,0.072090805,-0.11864065,0.1221837],[0.0066026353,-0.026799738,0.06792141,-0.1163357,0.12696873],[0.0058281208,-0.024337724,0.063733807,-0.11362296,0.13115534],[0.0051155216,-0.021993352,0.0595488,-0.1105266,0.13472022],[0.0044623282,-0.019769047,0.055386468,-0.10707275,0.13764448],[0.003865955,-0.017666527,0.051266056,-0.10328925,0.13991387],[0.0033237563,-0.015686825,0.047205884,-0.099205473,0.14151875],[0.0028330407,-0.013830311,0.043223263,-0.094852055,0.14245418],[0.0023910865,-0.012096714,0.039334412,-0.090260689,0.1427199],[0.0019951549,-0.010485159,0.035554394,-0.085463871,0.14232031],[0.0016425045,-0.0089941908,0.031897053,-0.080494669,0.14126437],[0.001330404,-0.0076218102,0.02837497,-0.075386477,0.13956553],[0.0010561444,-0.0063655113,0.024999421,-0.070172781,0.13724155],[0.00081705134,-0.0052223175,0.021780346,-0.06488692,0.13431436],[0.00061049556,-0.0041888209,0.018726333,-0.059561861,0.13080983]]).T

# windows to be used for the slepian sequence
# assumes that we are applying the slepian sequences to a
# length 320 window, have this hard coded in because
# we don't want to keep redoing the calculation
E_slep = np.array([[9.9382605e-05,0.00077593566,0.0040407525,0.015842045,0.046973574,0.10006025,],
[0.00012418049,0.00092638741,0.00461454,0.017338766,0.049435795,0.10169631,],
[0.00015194448,0.0010903375,0.0052229954,0.018881048,0.051884752,0.10317456,],
[0.00018287825,0.0012683767,0.0058666155,0.020467181,0.054314826,0.10449045,],
[0.00021719244,0.0014610962,0.006545838,0.022095312,0.056720359,0.10563983,],
[0.0002551046,0.0016690867,0.0072610387,0.023763441,0.059095669,0.10661895,],
[0.00029683912,0.0018929368,0.0080125295,0.025469428,0.061435065,0.10742446,],
[0.00034262713,0.0021332318,0.008800555,0.027210995,0.063732862,0.10805344,],
[0.00039270639,0.0023905526,0.0096252908,0.028985723,0.065983393,0.1085034,],
[0.00044732117,0.002665474,0.010486841,0.030791065,0.068181028,0.10877229,],
[0.00050672211,0.0029585632,0.011385234,0.032624339,0.070320186,0.1088585,],
[0.00057116606,0.003270379,0.012320426,0.034482743,0.072395353,0.10876091,],
[0.00064091591,0.0036014697,0.013292292,0.036363348,0.074401092,0.10847881,],
[0.00071624037,0.0039523718,0.014300628,0.038263114,0.076332064,0.108012,],
[0.00079741382,0.0043236088,0.015345149,0.040178887,0.078183038,0.10736071,],
[0.000884716,0.0047156894,0.016425486,0.042107407,0.079948907,0.10652567,],
[0.00097843183,0.0051291058,0.017541189,0.044045317,0.081624705,0.10550805,],
[0.0010788511,0.005564333,0.018691717,0.045989164,0.083205618,0.10430952,],
[0.0011862683,0.0060218263,0.019876448,0.047935409,0.084686998,0.10293218,],
[0.0013009821,0.0065020202,0.021094669,0.049880433,0.08606438,0.10137862,],
[0.0014232953,0.0070053272,0.02234558,0.051820545,0.087333491,0.099651876,],
[0.0015535142,0.0075321356,0.023628293,0.053751988,0.088490266,0.097755424,],
[0.0016919487,0.0080828086,0.024941832,0.055670949,0.089530859,0.095693194,],
[0.0018389113,0.0086576824,0.02628513,0.057573563,0.090451656,0.093469547,],
[0.0019947173,0.0092570649,0.027657033,0.059455926,0.091249285,0.091089263,],
[0.0021596842,0.0098812342,0.029056298,0.0613141,0.091920628,0.088557537,],
[0.0023341312,0.010530437,0.030481595,0.063144126,0.092462832,0.085879961,],
[0.0025183786,0.011204888,0.031931506,0.064942025,0.092873315,0.083062512,],
[0.0027127479,0.011904767,0.033404527,0.066703817,0.093149781,0.080111536,],
[0.002917561,0.012630218,0.03489907,0.068425521,0.093290225,0.077033735,],
[0.0031331395,0.01338135,0.036413462,0.070103172,0.093292939,0.073836146,],
[0.0033598047,0.014158233,0.037945951,0.071732824,0.093156523,0.070526125,],
[0.0035978768,0.014960898,0.039494701,0.073310565,0.092879888,0.067111329,],
[0.0038476744,0.015789334,0.041057802,0.074832521,0.092462265,0.063599694,],
[0.004109514,0.016643491,0.042633264,0.076294871,0.091903205,0.059999415,],
[0.0043837096,0.017523276,0.044219028,0.077693851,0.091202585,0.056318924,],
[0.0046705719,0.01842855,0.04581296,0.079025771,0.090360615,0.052566871,],
[0.0049704082,0.019359133,0.047412863,0.080287016,0.089377832,0.048752094,],
[0.0052835211,0.020314795,0.049016471,0.08147406,0.088255109,0.044883605,],
[0.0056102086,0.021295264,0.050621459,0.082583477,0.086993651,0.040970557,],
[0.0059507634,0.02230022,0.052225443,0.083611946,0.085594997,0.037022224,],
[0.0063054719,0.023329292,0.053825986,0.084556261,0.084061016,0.033047978,],
[0.0066746142,0.024382066,0.055420598,0.085413345,0.082393908,0.029057257,],
[0.007058463,0.025458074,0.057006745,0.08618025,0.0805962,0.025059547,],
[0.0074572833,0.026556801,0.058581849,0.086854173,0.07867074,0.021064351,],
[0.0078713318,0.027677684,0.060143295,0.087432461,0.076620694,0.017081167,],
[0.0083008561,0.028820107,0.061688434,0.087912617,0.074449541,0.013119459,],
[0.0087460943,0.029983406,0.06321459,0.088292313,0.072161066,0.0091886325,],
[0.0092072744,0.031166866,0.064719059,0.088569394,0.069759351,0.0052980092,],
[0.0096846135,0.032369721,0.066199122,0.088741883,0.06724877,0.0014568012,],
[0.010178317,0.033591156,0.067652043,0.088807993,0.064633976,-0.0023259142,],
[0.01068858,0.034830305,0.069075079,0.088766129,0.061919895,-0.0060412195,],
[0.011215583,0.036086254,0.070465482,0.088614897,0.059111715,-0.0096803816,],
[0.011759494,0.037358039,0.071820507,0.088353106,0.05621487,-0.013234875,],
[0.012320468,0.038644647,0.073137414,0.087979777,0.053235036,-0.016696408,],
[0.012898645,0.039945015,0.074413477,0.087494145,0.050178111,-0.02005694,],
[0.01349415,0.041258036,0.075645988,0.086895664,0.047050205,-0.02330871,],
[0.014107095,0.042582553,0.076832263,0.086184012,0.043857627,-0.026444255,],
[0.014737573,0.043917366,0.077969647,0.08535909,0.040606868,-0.029456428,],
[0.015385663,0.045261228,0.079055518,0.084421032,0.037304586,-0.032338425,],
[0.016051425,0.046612849,0.080087298,0.083370201,0.033957594,-0.035083795,],
[0.016734904,0.047970895,0.081062452,0.082207191,0.030572839,-0.037686466,],
[0.017436126,0.049333994,0.0819785,0.080932834,0.027157388,-0.040140753,],
[0.018155098,0.050700729,0.082833018,0.079548194,0.02371841,-0.042441384,],
[0.018891809,0.05206965,0.083623644,0.07805457,0.020263161,-0.044583506,],
[0.019646231,0.053439266,0.084348087,0.076453496,0.016798963,-0.046562703,],
[0.020418312,0.054808052,0.085004127,0.074746739,0.013333187,-0.048375004,],
[0.021207985,0.05617445,0.085589626,0.072936298,0.0098732379,-0.0500169,],
[0.02201516,0.057536869,0.08610253,0.071024403,0.0064265321,-0.051485348,],
[0.022839726,0.05889369,0.086540875,0.069013507,0.0030004811,-0.052777782,],
[0.023681554,0.060243265,0.08690279,0.066906293,-0.00039752702,-0.053892121,],
[0.024540491,0.06158392,0.087186507,0.064705658,-0.0037601468,-0.054826769,],
[0.025416365,0.062913958,0.087390361,0.062414719,-0.0070800933,-0.055580628,],
[0.026308981,0.064231661,0.087512796,0.060036803,-0.010350161,-0.056153092,],
[0.027218122,0.065535291,0.08755237,0.057575441,-0.013563242,-0.056544055,],
[0.028143552,0.066823096,0.087507759,0.055034366,-0.016712343,-0.056753906,],
[0.029085009,0.068093308,0.087377761,0.052417503,-0.019790606,-0.056783532,],
[0.030042212,0.069344146,0.087161302,0.049728963,-0.022791322,-0.056634311,],
[0.031014857,0.070573823,0.086857434,0.046973036,-0.025707954,-0.05630811,],
[0.032002617,0.071780543,0.086465346,0.044154186,-0.028534147,-0.05580728,],
[0.033005144,0.072962509,0.085984361,0.041277035,-0.031263749,-0.055134647,],
[0.034022067,0.07411792,0.085413943,0.038346362,-0.033890829,-0.054293505,],
[0.035052993,0.075244979,0.084753696,0.03536709,-0.036409685,-0.053287605,],
[0.036097509,0.076341893,0.084003371,0.032344279,-0.038814868,-0.052121144,],
[0.037155176,0.077406876,0.083162865,0.02928311,-0.04110119,-0.050798755,],
[0.038225538,0.078438153,0.082232225,0.026188884,-0.04326374,-0.049325491,],
[0.039308115,0.079433961,0.081211647,0.023067001,-0.0452979,-0.04770681,],
[0.040402405,0.080392554,0.08010148,0.019922959,-0.047199351,-0.04594856,],
[0.041507888,0.081312204,0.078902227,0.016762333,-0.048964091,-0.044056963,],
[0.04262402,0.082191207,0.077614542,0.013590773,-0.050588442,-0.042038593,],
[0.043750239,0.08302788,0.076239237,0.010413985,-0.052069063,-0.039900362,],
[0.044885962,0.08382057,0.074777277,0.0072377204,-0.053402957,-0.037649496,],
[0.046030587,0.084567656,0.073229782,0.0040677671,-0.054587479,-0.035293515,],
[0.047183493,0.085267547,0.071598026,0.00090993361,-0.055620347,-0.03284021,],
[0.048344039,0.08591869,0.069883436,-0.0022299618,-0.056499645,-0.030297624,],
[0.049511567,0.086519571,0.068087594,-0.0053461043,-0.05722383,-0.027674024,],
[0.050685402,0.087068717,0.06621223,-0.0084326949,-0.057791738,-0.024977881,],
[0.051864851,0.087564702,0.064259226,-0.011483963,-0.058202586,-0.02221784,],
[0.053049204,0.088006143,0.06223061,-0.01449418,-0.058455973,-0.019402701,],
[0.054237737,0.088391711,0.060128556,-0.01745767,-0.058551889,-0.016541391,],
[0.05542971,0.088720127,0.057955382,-0.020368826,-0.058490707,-0.013642935,],
[0.056624367,0.088990168,0.055713543,-0.023222118,-0.058273188,-0.010716433,],
[0.057820941,0.089200669,0.053405634,-0.026012109,-0.057900479,-0.0077710359,],
[0.05901865,0.089350523,0.051034381,-0.028733466,-0.05737411,-0.0048159122,],
[0.060216701,0.089438687,0.048602641,-0.031380972,-0.05669599,-0.0018602271,],
[0.061414289,0.089464183,0.046113395,-0.033949537,-0.055868406,0.0010868866,],
[0.062610598,0.089426096,0.043569747,-0.036434214,-0.054894014,0.0040163542,],
[0.063804803,0.089323585,0.040974916,-0.038830205,-0.053775835,0.0069191861,],
[0.064996069,0.089155875,0.038332234,-0.041132875,-0.052517247,0.009786503,],
[0.066183556,0.088922266,0.035645138,-0.043337761,-0.051121979,0.012609562,],
[0.067366412,0.088622132,0.032917169,-0.045440588,-0.049594097,0.015379784,],
[0.068543784,0.088254921,0.030151961,-0.04743727,-0.047937999,0.018088773,],
[0.06971481,0.087820162,0.02735324,-0.049323928,-0.046158404,0.020728346,],
[0.070878626,0.08731746,0.024524813,-0.051096897,-0.044260337,0.023290556,],
[0.072034363,0.086746501,0.021670568,-0.052752731,-0.042249118,0.02576771,],
[0.073181152,0.086107052,0.018794463,-0.054288216,-0.04013035,0.028152399,],
[0.074318119,0.085398965,0.01590052,-0.055700377,-0.037909903,0.030437511,],
[0.075444395,0.084622172,0.012992818,-0.056986485,-0.035593902,0.032616259,],
[0.076559107,0.083776692,0.01007549,-0.058144062,-0.033188708,0.034682195,],
[0.077661386,0.082862626,0.0071527107,-0.05917089,-0.030700905,0.036629231,],
[0.078750366,0.081880163,0.0042286912,-0.060065018,-0.02813728,0.038451656,],
[0.079825183,0.080829578,0.0013076729,-0.060824762,-0.02550481,0.040144154,],
[0.080884981,0.079711229,-0.0016060809,-0.061448715,-0.022810641,0.041701814,],
[0.081928908,0.078525564,-0.0045082927,-0.061935746,-0.02006207,0.043120152,],
[0.082956118,0.077273115,-0.0073946777,-0.06228501,-0.017266527,0.044395116,],
[0.083965776,0.075954501,-0.010260952,-0.062495945,-0.014431558,0.045523101,],
[0.084957053,0.074570426,-0.01310284,-0.062568274,-0.0115648,0.046500959,],
[0.085929131,0.073121681,-0.015916082,-0.062502013,-0.0086739682,0.047326008,],
[0.086881206,0.071609139,-0.018696441,-0.062297463,-0.0057668307,0.047996038,],
[0.087812481,0.07003376,-0.021439713,-0.061955217,-0.0028511914,0.048509319,],
[0.088722176,0.068396586,-0.024141731,-0.061476158,6.5131295e-05,0.048864602,],
[0.089609525,0.06669874,-0.026798376,-0.060861453,0.0029743243,0.049061126,],
[0.090473774,0.064941429,-0.029405583,-0.06011256,0.0058686001,0.049098617,],
[0.091314189,0.063125937,-0.031959346,-0.059231217,0.0087402172,0.04897729,],
[0.092130051,0.061253627,-0.03445573,-0.058219445,0.0115815,0.048697848,],
[0.092920658,0.059325941,-0.036890876,-0.05707954,0.014384858,0.048261475,],
[0.093685329,0.057344393,-0.039261008,-0.055814072,0.017142809,0.047669839,],
[0.094423402,0.055310572,-0.041562439,-0.054425879,0.019847991,0.046925081,],
[0.095134235,0.053226138,-0.043791581,-0.052918058,0.022493192,0.046029808,],
[0.095817208,0.051092822,-0.045944948,-0.051293966,0.025071358,0.04498709,],
[0.096471723,0.048912419,-0.048019164,-0.049557206,0.027575619,0.043800445,],
[0.097097206,0.046686793,-0.050010972,-0.047711622,0.029999305,0.042473828,],
[0.097693105,0.044417866,-0.051917236,-0.045761295,0.03233596,0.041011623,],
[0.098258894,0.042107624,-0.053734947,-0.043710528,0.034579364,0.039418626,],
[0.098794071,0.039758108,-0.055461234,-0.041563841,0.036723546,0.037700031,],
[0.099298162,0.037371414,-0.057093362,-0.039325962,0.038762801,0.035861413,],
[0.099770718,0.03494969,-0.058628742,-0.037001813,0.040691702,0.033908714,],
[0.10021132,0.032495134,-0.060064936,-0.034596505,0.042505121,0.031848222,],
[0.10061956,0.030009989,-0.061399658,-0.032115323,0.044198234,0.02968655,],
[0.1009951,0.027496541,-0.062630784,-0.029563716,0.045766539,0.027430622,],
[0.10133757,0.024957114,-0.063756348,-0.026947284,0.047205868,0.025087646,],
[0.10164669,0.022394073,-0.064774554,-0.024271771,0.048512394,0.022665095,],
[0.10192217,0.019809811,-0.065683775,-0.021543046,0.049682645,0.020170684,],
[0.10216376,0.017206755,-0.066482556,-0.018767094,0.05071351,0.017612344,],
[0.10237124,0.014587357,-0.067169618,-0.015950003,0.05160225,0.014998202,],
[0.10254443,0.01195409,-0.067743861,-0.01309795,0.052346504,0.012336553,],
[0.10268317,0.0093094509,-0.068204365,-0.010217186,0.052944294,0.0096358376,],
[0.10278734,0.0066559489,-0.068550391,-0.0073140282,0.053394031,0.0069046129,],
[0.10285683,0.0039961076,-0.068781384,-0.0043948391,0.053694522,0.0041515297,],
[0.1028916,0.0013324591,-0.068896973,-0.0014660174,0.053844967,0.0013853049,],
[0.1028916,-0.0013324591,-0.068896973,0.0014660174,0.053844967,-0.0013853049,],
[0.10285683,-0.0039961076,-0.068781384,0.0043948391,0.053694522,-0.0041515297,],
[0.10278734,-0.0066559489,-0.068550391,0.0073140282,0.053394031,-0.0069046129,],
[0.10268317,-0.0093094509,-0.068204365,0.010217186,0.052944294,-0.0096358376,],
[0.10254443,-0.01195409,-0.067743861,0.01309795,0.052346504,-0.012336553,],
[0.10237124,-0.014587357,-0.067169618,0.015950003,0.05160225,-0.014998202,],
[0.10216376,-0.017206755,-0.066482556,0.018767094,0.05071351,-0.017612344,],
[0.10192217,-0.019809811,-0.065683775,0.021543046,0.049682645,-0.020170684,],
[0.10164669,-0.022394073,-0.064774554,0.024271771,0.048512394,-0.022665095,],
[0.10133757,-0.024957114,-0.063756348,0.026947284,0.047205868,-0.025087646,],
[0.1009951,-0.027496541,-0.062630784,0.029563716,0.045766539,-0.027430622,],
[0.10061956,-0.030009989,-0.061399658,0.032115323,0.044198234,-0.02968655,],
[0.10021132,-0.032495134,-0.060064936,0.034596505,0.042505121,-0.031848222,],
[0.099770718,-0.03494969,-0.058628742,0.037001813,0.040691702,-0.033908714,],
[0.099298162,-0.037371414,-0.057093362,0.039325962,0.038762801,-0.035861413,],
[0.098794071,-0.039758108,-0.055461234,0.041563841,0.036723546,-0.037700031,],
[0.098258894,-0.042107624,-0.053734947,0.043710528,0.034579364,-0.039418626,],
[0.097693105,-0.044417866,-0.051917236,0.045761295,0.03233596,-0.041011623,],
[0.097097206,-0.046686793,-0.050010972,0.047711622,0.029999305,-0.042473828,],
[0.096471723,-0.048912419,-0.048019164,0.049557206,0.027575619,-0.043800445,],
[0.095817208,-0.051092822,-0.045944948,0.051293966,0.025071358,-0.04498709,],
[0.095134235,-0.053226138,-0.043791581,0.052918058,0.022493192,-0.046029808,],
[0.094423402,-0.055310572,-0.041562439,0.054425879,0.019847991,-0.046925081,],
[0.093685329,-0.057344393,-0.039261008,0.055814072,0.017142809,-0.047669839,],
[0.092920658,-0.059325941,-0.036890876,0.05707954,0.014384858,-0.048261475,],
[0.092130051,-0.061253627,-0.03445573,0.058219445,0.0115815,-0.048697848,],
[0.091314189,-0.063125937,-0.031959346,0.059231217,0.0087402172,-0.04897729,],
[0.090473774,-0.064941429,-0.029405583,0.06011256,0.0058686001,-0.049098617,],
[0.089609525,-0.06669874,-0.026798376,0.060861453,0.0029743243,-0.049061126,],
[0.088722176,-0.068396586,-0.024141731,0.061476158,6.5131295e-05,-0.048864602,],
[0.087812481,-0.07003376,-0.021439713,0.061955217,-0.0028511914,-0.048509319,],
[0.086881206,-0.071609139,-0.018696441,0.062297463,-0.0057668307,-0.047996038,],
[0.085929131,-0.073121681,-0.015916082,0.062502013,-0.0086739682,-0.047326008,],
[0.084957053,-0.074570426,-0.01310284,0.062568274,-0.0115648,-0.046500959,],
[0.083965776,-0.075954501,-0.010260952,0.062495945,-0.014431558,-0.045523101,],
[0.082956118,-0.077273115,-0.0073946777,0.06228501,-0.017266527,-0.044395116,],
[0.081928908,-0.078525564,-0.0045082927,0.061935746,-0.02006207,-0.043120152,],
[0.080884981,-0.079711229,-0.0016060809,0.061448715,-0.022810641,-0.041701814,],
[0.079825183,-0.080829578,0.0013076729,0.060824762,-0.02550481,-0.040144154,],
[0.078750366,-0.081880163,0.0042286912,0.060065018,-0.02813728,-0.038451656,],
[0.077661386,-0.082862626,0.0071527107,0.05917089,-0.030700905,-0.036629231,],
[0.076559107,-0.083776692,0.01007549,0.058144062,-0.033188708,-0.034682195,],
[0.075444395,-0.084622172,0.012992818,0.056986485,-0.035593902,-0.032616259,],
[0.074318119,-0.085398965,0.01590052,0.055700377,-0.037909903,-0.030437511,],
[0.073181152,-0.086107052,0.018794463,0.054288216,-0.04013035,-0.028152399,],
[0.072034363,-0.086746501,0.021670568,0.052752731,-0.042249118,-0.02576771,],
[0.070878626,-0.08731746,0.024524813,0.051096897,-0.044260337,-0.023290556,],
[0.06971481,-0.087820162,0.02735324,0.049323928,-0.046158404,-0.020728346,],
[0.068543784,-0.088254921,0.030151961,0.04743727,-0.047937999,-0.018088773,],
[0.067366412,-0.088622132,0.032917169,0.045440588,-0.049594097,-0.015379784,],
[0.066183556,-0.088922266,0.035645138,0.043337761,-0.051121979,-0.012609562,],
[0.064996069,-0.089155875,0.038332234,0.041132875,-0.052517247,-0.009786503,],
[0.063804803,-0.089323585,0.040974916,0.038830205,-0.053775835,-0.0069191861,],
[0.062610598,-0.089426096,0.043569747,0.036434214,-0.054894014,-0.0040163542,],
[0.061414289,-0.089464183,0.046113395,0.033949537,-0.055868406,-0.0010868866,],
[0.060216701,-0.089438687,0.048602641,0.031380972,-0.05669599,0.0018602271,],
[0.05901865,-0.089350523,0.051034381,0.028733466,-0.05737411,0.0048159122,],
[0.057820941,-0.089200669,0.053405634,0.026012109,-0.057900479,0.0077710359,],
[0.056624367,-0.088990168,0.055713543,0.023222118,-0.058273188,0.010716433,],
[0.05542971,-0.088720127,0.057955382,0.020368826,-0.058490707,0.013642935,],
[0.054237737,-0.088391711,0.060128556,0.01745767,-0.058551889,0.016541391,],
[0.053049204,-0.088006143,0.06223061,0.01449418,-0.058455973,0.019402701,],
[0.051864851,-0.087564702,0.064259226,0.011483963,-0.058202586,0.02221784,],
[0.050685402,-0.087068717,0.06621223,0.0084326949,-0.057791738,0.024977881,],
[0.049511567,-0.086519571,0.068087594,0.0053461043,-0.05722383,0.027674024,],
[0.048344039,-0.08591869,0.069883436,0.0022299618,-0.056499645,0.030297624,],
[0.047183493,-0.085267547,0.071598026,-0.00090993361,-0.055620347,0.03284021,],
[0.046030587,-0.084567656,0.073229782,-0.0040677671,-0.054587479,0.035293515,],
[0.044885962,-0.08382057,0.074777277,-0.0072377204,-0.053402957,0.037649496,],
[0.043750239,-0.08302788,0.076239237,-0.010413985,-0.052069063,0.039900362,],
[0.04262402,-0.082191207,0.077614542,-0.013590773,-0.050588442,0.042038593,],
[0.041507888,-0.081312204,0.078902227,-0.016762333,-0.048964091,0.044056963,],
[0.040402405,-0.080392554,0.08010148,-0.019922959,-0.047199351,0.04594856,],
[0.039308115,-0.079433961,0.081211647,-0.023067001,-0.0452979,0.04770681,],
[0.038225538,-0.078438153,0.082232225,-0.026188884,-0.04326374,0.049325491,],
[0.037155176,-0.077406876,0.083162865,-0.02928311,-0.04110119,0.050798755,],
[0.036097509,-0.076341893,0.084003371,-0.032344279,-0.038814868,0.052121144,],
[0.035052993,-0.075244979,0.084753696,-0.03536709,-0.036409685,0.053287605,],
[0.034022067,-0.07411792,0.085413943,-0.038346362,-0.033890829,0.054293505,],
[0.033005144,-0.072962509,0.085984361,-0.041277035,-0.031263749,0.055134647,],
[0.032002617,-0.071780543,0.086465346,-0.044154186,-0.028534147,0.05580728,],
[0.031014857,-0.070573823,0.086857434,-0.046973036,-0.025707954,0.05630811,],
[0.030042212,-0.069344146,0.087161302,-0.049728963,-0.022791322,0.056634311,],
[0.029085009,-0.068093308,0.087377761,-0.052417503,-0.019790606,0.056783532,],
[0.028143552,-0.066823096,0.087507759,-0.055034366,-0.016712343,0.056753906,],
[0.027218122,-0.065535291,0.08755237,-0.057575441,-0.013563242,0.056544055,],
[0.026308981,-0.064231661,0.087512796,-0.060036803,-0.010350161,0.056153092,],
[0.025416365,-0.062913958,0.087390361,-0.062414719,-0.0070800933,0.055580628,],
[0.024540491,-0.06158392,0.087186507,-0.064705658,-0.0037601468,0.054826769,],
[0.023681554,-0.060243265,0.08690279,-0.066906293,-0.00039752702,0.053892121,],
[0.022839726,-0.05889369,0.086540875,-0.069013507,0.0030004811,0.052777782,],
[0.02201516,-0.057536869,0.08610253,-0.071024403,0.0064265321,0.051485348,],
[0.021207985,-0.05617445,0.085589626,-0.072936298,0.0098732379,0.0500169,],
[0.020418312,-0.054808052,0.085004127,-0.074746739,0.013333187,0.048375004,],
[0.019646231,-0.053439266,0.084348087,-0.076453496,0.016798963,0.046562703,],
[0.018891809,-0.05206965,0.083623644,-0.07805457,0.020263161,0.044583506,],
[0.018155098,-0.050700729,0.082833018,-0.079548194,0.02371841,0.042441384,],
[0.017436126,-0.049333994,0.0819785,-0.080932834,0.027157388,0.040140753,],
[0.016734904,-0.047970895,0.081062452,-0.082207191,0.030572839,0.037686466,],
[0.016051425,-0.046612849,0.080087298,-0.083370201,0.033957594,0.035083795,],
[0.015385663,-0.045261228,0.079055518,-0.084421032,0.037304586,0.032338425,],
[0.014737573,-0.043917366,0.077969647,-0.08535909,0.040606868,0.029456428,],
[0.014107095,-0.042582553,0.076832263,-0.086184012,0.043857627,0.026444255,],
[0.01349415,-0.041258036,0.075645988,-0.086895664,0.047050205,0.02330871,],
[0.012898645,-0.039945015,0.074413477,-0.087494145,0.050178111,0.02005694,],
[0.012320468,-0.038644647,0.073137414,-0.087979777,0.053235036,0.016696408,],
[0.011759494,-0.037358039,0.071820507,-0.088353106,0.05621487,0.013234875,],
[0.011215583,-0.036086254,0.070465482,-0.088614897,0.059111715,0.0096803816,],
[0.01068858,-0.034830305,0.069075079,-0.088766129,0.061919895,0.0060412195,],
[0.010178317,-0.033591156,0.067652043,-0.088807993,0.064633976,0.0023259142,],
[0.0096846135,-0.032369721,0.066199122,-0.088741883,0.06724877,-0.0014568012,],
[0.0092072744,-0.031166866,0.064719059,-0.088569394,0.069759351,-0.0052980092,],
[0.0087460943,-0.029983406,0.06321459,-0.088292313,0.072161066,-0.0091886325,],
[0.0083008561,-0.028820107,0.061688434,-0.087912617,0.074449541,-0.013119459,],
[0.0078713318,-0.027677684,0.060143295,-0.087432461,0.076620694,-0.017081167,],
[0.0074572833,-0.026556801,0.058581849,-0.086854173,0.07867074,-0.021064351,],
[0.007058463,-0.025458074,0.057006745,-0.08618025,0.0805962,-0.025059547,],
[0.0066746142,-0.024382066,0.055420598,-0.085413345,0.082393908,-0.029057257,],
[0.0063054719,-0.023329292,0.053825986,-0.084556261,0.084061016,-0.033047978,],
[0.0059507634,-0.02230022,0.052225443,-0.083611946,0.085594997,-0.037022224,],
[0.0056102086,-0.021295264,0.050621459,-0.082583477,0.086993651,-0.040970557,],
[0.0052835211,-0.020314795,0.049016471,-0.08147406,0.088255109,-0.044883605,],
[0.0049704082,-0.019359133,0.047412863,-0.080287016,0.089377832,-0.048752094,],
[0.0046705719,-0.01842855,0.04581296,-0.079025771,0.090360615,-0.052566871,],
[0.0043837096,-0.017523276,0.044219028,-0.077693851,0.091202585,-0.056318924,],
[0.004109514,-0.016643491,0.042633264,-0.076294871,0.091903205,-0.059999415,],
[0.0038476744,-0.015789334,0.041057802,-0.074832521,0.092462265,-0.063599694,],
[0.0035978768,-0.014960898,0.039494701,-0.073310565,0.092879888,-0.067111329,],
[0.0033598047,-0.014158233,0.037945951,-0.071732824,0.093156523,-0.070526125,],
[0.0031331395,-0.01338135,0.036413462,-0.070103172,0.093292939,-0.073836146,],
[0.002917561,-0.012630218,0.03489907,-0.068425521,0.093290225,-0.077033735,],
[0.0027127479,-0.011904767,0.033404527,-0.066703817,0.093149781,-0.080111536,],
[0.0025183786,-0.011204888,0.031931506,-0.064942025,0.092873315,-0.083062512,],
[0.0023341312,-0.010530437,0.030481595,-0.063144126,0.092462832,-0.085879961,],
[0.0021596842,-0.0098812342,0.029056298,-0.0613141,0.091920628,-0.088557537,],
[0.0019947173,-0.0092570649,0.027657033,-0.059455926,0.091249285,-0.091089263,],
[0.0018389113,-0.0086576824,0.02628513,-0.057573563,0.090451656,-0.093469547,],
[0.0016919487,-0.0080828086,0.024941832,-0.055670949,0.089530859,-0.095693194,],
[0.0015535142,-0.0075321356,0.023628293,-0.053751988,0.088490266,-0.097755424,],
[0.0014232953,-0.0070053272,0.02234558,-0.051820545,0.087333491,-0.099651876,],
[0.0013009821,-0.0065020202,0.021094669,-0.049880433,0.08606438,-0.10137862,],
[0.0011862683,-0.0060218263,0.019876448,-0.047935409,0.084686998,-0.10293218,],
[0.0010788511,-0.005564333,0.018691717,-0.045989164,0.083205618,-0.10430952,],
[0.00097843183,-0.0051291058,0.017541189,-0.044045317,0.081624705,-0.10550805,],
[0.000884716,-0.0047156894,0.016425486,-0.042107407,0.079948907,-0.10652567,],
[0.00079741382,-0.0043236088,0.015345149,-0.040178887,0.078183038,-0.10736071,],
[0.00071624037,-0.0039523718,0.014300628,-0.038263114,0.076332064,-0.108012,],
[0.00064091591,-0.0036014697,0.013292292,-0.036363348,0.074401092,-0.10847881,],
[0.00057116606,-0.003270379,0.012320426,-0.034482743,0.072395353,-0.10876091,],
[0.00050672211,-0.0029585632,0.011385234,-0.032624339,0.070320186,-0.1088585,],
[0.00044732117,-0.002665474,0.010486841,-0.030791065,0.068181028,-0.10877229,],
[0.00039270639,-0.0023905526,0.0096252908,-0.028985723,0.065983393,-0.1085034,],
[0.00034262713,-0.0021332318,0.008800555,-0.027210995,0.063732862,-0.10805344,],
[0.00029683912,-0.0018929368,0.0080125295,-0.025469428,0.061435065,-0.10742446,],
[0.0002551046,-0.0016690867,0.0072610387,-0.023763441,0.059095669,-0.10661895,],
[0.00021719244,-0.0014610962,0.006545838,-0.022095312,0.056720359,-0.10563983,],
[0.00018287825,-0.0012683767,0.0058666155,-0.020467181,0.054314826,-0.10449045,],
[0.00015194448,-0.0010903375,0.0052229954,-0.018881048,0.051884752,-0.10317456,],
[0.00012418049,-0.00092638741,0.00461454,-0.017338766,0.049435795,-0.10169631,],
[9.9382605e-05,-0.00077593566,0.0040407525,-0.015842045,0.046973574,-0.10006025,],
]).T


def has_pattern(pattern,labels):
    pattern_length = pattern.shape[0]
    for l in xrange(labels.shape[0]-pattern_length):
        if np.all(labels[l:l+pattern_length] == pattern):
            return True
    return False




class Pattern_Examples:
    def __init__(self,data_files_iter,pattern,
                 sample_rate,num_window_samples,
                 num_window_step_samples,fft_length,
                 freq_cutoff,kernel_length):
        self.examples = []
        self.data_files_iter = data_files_iter
        self.pattern = pattern
        self.sample_rate = sample_rate
        self.num_window_samples = num_window_samples
        self.num_window_step_samples = num_window_step_samples
        self.fft_length = fft_length
        self.freq_cutoff = freq_cutoff
        self.kernel_length = kernel_length

    def __iter__(self):
        return self

    def next(self):
        while True:
            get_s,labels,label_times = self.data_files_iter.next()
            if not(has_pattern(self.pattern,labels)):
                continue
            else:
                s = get_s()
            self.labels = labels
            feature_start, \
                feature_step, num_features =\
                _get_feature_label_times(s,
                                         self.num_window_samples,
                                         self.num_window_step_samples)
            feature_labels, \
                feature_label_transitions \
                = _get_labels(label_times,
                              labels,
                              feature_start, feature_step, num_features,
                            self.sample_rate)
            self.times = get_pattern_times(self.pattern,
                                              labels,
                                              feature_label_transitions)
            self.feature_labels = feature_labels
            self.feature_label_transitions = feature_label_transitions
            # check that pattern is in the example signal
            # before doing signal processing
            if self.times:
                self.E = get_edgemap_features(s,self.sample_rate,
                                              self.num_window_samples,
                                              self.num_window_step_samples,
                                              self.fft_length,
                                              self.freq_cutoff,
                                              self.kernel_length)
                self.examples.extend([self.E[:,p[0]:p[1]]
                                         for p in self.times])
                print "pattern_examples now has length",len(self.examples)
            break


def magnitude_features(S,block_length,spread_radius,threshold_quantile,
                       mag_smooth_freq,
                       mag_downsample_freq,
                       mag_spread_length=1):
    """
    Construct a binary map from a spectrogram where values are binarized
    via an adaptive threshold.

    The algorithm proceeds as follows: we are attempting to find the
    top values in a band, to prevent aliasing we do a windowing operation.
    
    The start time for the windows is  [-block_length/4,3*block_length/4]
    the next is over [block_length/4,5*block_length/4] then
    [3*block_length/4, 7*block_length/4], ...
    these are the windows for estimating the quantiles

    The windows that we actually set the quantiles for are 
    [0,block_length/2], [block_length/2,block_length],
    [block_length,3*block_length/2], ...
    where these correspond to the middle half of the estimation windows
    
    Parameters:
    ===========
    S: numpy.ndarray[ndim=2]
        Dimension 0 corresponds to frequency, dimension 1 corresponds to time
        this is the spectrogram to be quantized
    block_length: int
        Length of block to use for estimating the threshold
    spread_radius: int
        How much to spread in a radius
    threshold_quantile: float
        Quantile for thresholding

    Returns:
    ========
    E: numpy.ndarray[ndim=2]
        Dimension 0 corresponds to the time dimension and dimension 1
        to the frequency dimension.  These are the binary magnitude features
    """

    if mag_smooth_freq > 0:
        S = maximum_filter(S,(mag_smooth_freq,1))
    if mag_downsample_freq > 0:
        S = S[::mag_downsample_freq]
    num_features, num_frames = S.shape
    block_quarter = block_length/4
    S = S.T
    E = np.zeros(S.shape,dtype=np.uint8)
    # handling the initial window
    block = np.sort(S[:3*block_quarter],axis=0)
    E[:2*block_quarter]  = S[:2*block_quarter] >= block[int(threshold_quantile*3*block_quarter+.5)]
    next_frame_to_set = 2*block_quarter
    while next_frame_to_set < num_frames:
        estimate_win_start = next_frame_to_set-block_quarter
        estimate_win_end = min(num_frames,
                               estimate_win_start+4*block_quarter)
        last_frame_to_set = min(next_frame_to_set + 2*block_quarter,
                                num_frames)
        block = np.sort(S[estimate_win_start:estimate_win_end],
                        axis=0)
        E[next_frame_to_set:last_frame_to_set] = (
            S[next_frame_to_set:last_frame_to_set]
            >= block[int(threshold_quantile*(estimate_win_end -
                                             estimate_win_start))])
        next_frame_to_set=last_frame_to_set

    
    # now we spread the detected points in all directions
    if mag_spread_length > 0:
        E = (maximum_filter(E,size=(2*mag_spread_length+1,1),mode='constant') ).astype(np.uint8)
    return E


def magnitude_features_whole_block(S,block_length,spread_radius,threshold_quantile,
                       mag_smooth_freq,
                       mag_downsample_freq):
    """
    Construct a binary map from a spectrogram where values are binarized
    via an adaptive threshold.

    The algorithm proceeds as follows: we are attempting to find the
    top values in a band, to prevent aliasing we do a windowing operation.
    
    The start time for the windows is  [-block_length/4,3*block_length/4]
    the next is over [block_length/4,5*block_length/4] then
    [3*block_length/4, 7*block_length/4], ...
    these are the windows for estimating the quantiles

    The windows that we actually set the quantiles for are 
    [0,block_length/2], [block_length/2,block_length],
    [block_length,3*block_length/2], ...
    where these correspond to the middle half of the estimation windows
    
    Parameters:
    ===========
    S: numpy.ndarray[ndim=2]
        Dimension 0 corresponds to frequency, dimension 1 corresponds to time
        this is the spectrogram to be quantized
    block_length: int
        Length of block to use for estimating the threshold
    spread_radius: int
        How much to spread in a radius
    threshold_quantile: float
        Quantile for thresholding

    Returns:
    ========
    E: numpy.ndarray[ndim=2]
        Dimension 0 corresponds to the time dimension and dimension 1
        to the frequency dimension.  These are the binary magnitude features
    """
    if mag_smooth_freq > 0:
        S = maximum_filter(S,(mag_smooth_freq,1))
    if mag_downsample_freq > 0:
        S = S[::mag_downsample_freq]
    num_features, num_frames = S.shape
    block_quarter = block_length/4
    S = S.T
    E = np.zeros(S.shape,dtype=np.uint8)

    # handling the initial window
    block = np.sort(S[:3*block_quarter].ravel())
    E[:2*block_quarter]  = S[:2*block_quarter] >= block[int(threshold_quantile*3*block_quarter*S.shape[1]+.5)]
    next_frame_to_set = 2*block_quarter
    while next_frame_to_set < num_frames:
        estimate_win_start = next_frame_to_set-block_quarter
        estimate_win_end = min(num_frames,
                               estimate_win_start+4*block_quarter)
        last_frame_to_set = min(next_frame_to_set + 2*block_quarter,
                                num_frames)
        block = np.sort(S[estimate_win_start:estimate_win_end].ravel()
                        )
        E[next_frame_to_set:last_frame_to_set] = (
            S[next_frame_to_set:last_frame_to_set]
            >= block[int(threshold_quantile*(estimate_win_end -
                                             estimate_win_start)*S.shape[1])])
        next_frame_to_set=last_frame_to_set
        
    # now we spread the detected points in all directions
    if spread_radius > 0:
        weight_filter = np.ones((2*spread_radius+1,2*spread_radius+1)) * 1./spread_radius
        weight_filter[spread_radius,spread_radius]=1
        E = (correlate(E,weight_filter,mode='constant') >= 1).astype(np.uint8)

 
    return E.astype(np.uint8)

    

def get_pattern_examples(data_files_iter,pattern,
                         sample_rate,num_window_samples,
                         num_window_step_samples,fft_length,
                         freq_cutoff,kernel_length):
    pattern_examples = []
    while True:
        try:
            get_s,labels,label_times = data_files_iter.next()
            if not(has_pattern(pattern,labels)):
                continue
            else:
                s = get_s()
            feature_start, \
                feature_step, num_features =\
                _get_feature_label_times(s,
                                         num_window_samples,
                                         num_window_step_samples)
            feature_labels, \
                feature_label_transitions \
                = _get_labels(label_times,
                              labels,
                              feature_start,
                              feature_step,
                              num_features,
                              sample_rate)
            pattern_times = get_pattern_times(pattern,
                                              labels,
                                              feature_label_transitions)
            # check that pattern is in the example signal
            # before doing signal processing
            if pattern_times:
                E = get_edgemap_features(s,sample_rate,
                                         num_window_samples,
                                         num_window_step_samples,
                                         fft_length,
                                         freq_cutoff,
                                         kernel_length)
                pattern_examples.extend([E[:,p[0]:p[1]]
                                         for p in pattern_times])
                print "pattern_examples now has length",len(pattern_examples)
        except: # exhausted iterator
            return pattern_examples

def get_pattern_times(patterns,labels,feature_label_transitions):
    """
    Parameters
    ----------
    pattern:
       array of strings that represents the pattern we are
       looking for
    labels:
        array of strings that contains the labels for the sequence
    feature_label_transitions:
        array of positive integers that says at which edge map
        feature the next label starts

    Output
    ------
    pattern_times:
       tuples where the zeroth entry is the start frame of the pattern and the 1th entry
       is the next frame after the last frame of the pattern
    """
    pattern_times = []
    for pattern in patterns:
        pattern_length = pattern.shape[0]
        for l in xrange(labels.shape[0]-pattern_length):
            if np.all(labels[l:l+pattern_length] == pattern):
                pattern_times.append((feature_label_transitions[l],
                                      feature_label_transitions[l+pattern_length]))
    return pattern_times

def get_pattern_part_times(pattern,labels,feature_label_transitions):
    """
    Parameters
    ----------
    pattern:
       array of strings that represents the pattern we are
       looking for
    labels:
        array of strings that contains the labels for the sequence
    feature_label_transitions:
        array of positive integers that says at which edge map
        feature the next label starts

    Output
    ------
    pattern_times:
       tuples where the zeroth entry is the start frame of the pattern and the 1th entry
       is the next frame after the last frame of the pattern
    """
    pattern_length = pattern.shape[0]
    pattern_part_times = []
    for l in xrange(labels.shape[0]-pattern_length):
        if np.all(labels[l:l+pattern_length] == pattern):
            part_times = []
            for pattern_part_id in xrange(pattern_length):
                part_times.append((feature_label_transitions[l+pattern_part_id],
                                   feature_label_transitions[l+pattern_part_id+1]))
            pattern_part_times.append(part_times)
    return pattern_part_times


def get_pattern_negative(pattern,labels,feature_label_transitions,length):
    """
    Parameters
    ----------
    pattern:
       array of strings that represents the pattern we are
       looking for
    labels:
        array of strings that contains the labels for the sequence
    feature_label_transitions:
        array of positive integers that says at which edge map
        feature the next label starts

    Output
    ------
    pattern_times:
       tuples where the zeroth entry is the start frame of the pattern and the 1th entry
       is the next frame after the last frame of the pattern
    """
    pattern_length = pattern.shape[0]
    pattern_times = []
    for l in xrange(labels.shape[0]-pattern_length):
        if np.all(labels[l:l+pattern_length] == pattern):
            pattern_times.append((feature_label_transitions[l],
                                  feature_label_transitions[l+pattern_length]))
    negative_pattern_time = np.random.randint()
    return pattern_times


def _get_feature_label_times(s,
                            num_window_samples,
                            num_window_step_samples):
    feature_start, feature_step, num_features = _get_windows_sample_stats(s,num_window_samples,num_window_step_samples)
    return _get_edge_sample_stats(feature_start,feature_step,num_features)

def _get_spectrogram_label_times(s,
                            num_window_samples,
                            num_window_step_samples):
    return _get_windows_sample_stats(s,num_window_samples,num_window_step_samples)

def smooth_downsample_spectrogram(S,downsample_factor,bin_width=None):
    """
    Parameters:
    ==========
    S: numpy.ndarray[ndim=2]
       dim 0 is the feature axis and dim 1 is the time axis.
       We downsample and smooth along the dim 0 axis -- over the
       spectral features
    downsample_factor: int
       Factor by which we downsample, choose the bins so that way
       we get ``downsample_factor`` number of bins, bin_width
       is then not used
    bin_width: [optional] int
       If this is not None (and its assumed to be an integer) then
       choose the number of bins so that way we get bins of this length
       one bin might be shorter
    """
    
    

def get_spectrogram_features(s,sample_rate,num_window_samples,
                          num_window_step_samples,fft_length,
                             freq_cutoff,kernel_length,
                             preemph=.95,mode="valid",
                             no_use_dpss=False,
                             do_freq_smoothing=True,
                             auxiliary_data=False,
                             return_sample_mapping=False):
    """
    Parameters:
    ===========
    return_sample_mapping: bool
        returns sample_mapping which is a 1d array
        of floats such that entry i is the middle sample
        corresponding to spectrogram frame i.

    Output:
    =======
    sample_mapping: 1d array
        1d array
        of floats such that entry i is the middle sample
        corresponding to spectrogram frame i
    """
    s = _preemphasis(s,preemph)
    if auxiliary_data:
        S,A = _spectrograms(s,num_window_samples,
                      num_window_step_samples,
                      fft_length,
                      sample_rate,
                      no_use_dpss=no_use_dpss,
                          auxiliary_data=auxiliary_data)
    elif return_sample_mapping:
        S, sample_to_frames = _spectrograms(s,num_window_samples,
                      num_window_step_samples,
                      fft_length,
                      sample_rate,
                      no_use_dpss=no_use_dpss,
                          return_frame_to_sample_mapping=return_sample_mapping)
    else:
        S = _spectrograms(s,num_window_samples,
                      num_window_step_samples,
                      fft_length,
                      sample_rate,
                      no_use_dpss=no_use_dpss,
                          return_frame_to_sample_mapping=return_sample_mapping)

    freq_idx = int(freq_cutoff/(float(sample_rate)/fft_length))
    S = S[:,:freq_idx]

    # correct for the shape
    # we want each row of S to correspond to a frequency
    # and we want the bottom row to represent the lowest
    # frequency

    S[S== 0] = S[S!=0].min()
    S = np.log(S)
    # S = S[::-1,:]
    # smooth the spectrogram
    x = np.arange(0, kernel_length, 1, np.float64)
    x0 = kernel_length // 2.
    sigma = 1
    g=1/(sigma * np.sqrt(2*np.pi)) *np.exp(-((x-x0)**2  / 2* sigma**2))
    smoothing_kernel = g/g.sum()
    # feature smoothing should leave only meaningful features
    if do_freq_smoothing:
        S_smoothed = convolve(S,smoothing_kernel.reshape(1,kernel_length),mode ='valid')
    else:
        S_smoothed = S
        # preserve time length of spectrogram, smooth over time
    S_smoothed= convolve(S_smoothed,smoothing_kernel.reshape(kernel_length,1),mode='same')
    S_subsampled = S_smoothed[:,::2]

    if return_sample_mapping:
        return S_subsampled, np.arange(len(S_subsampled),dtype=float)*num_window_step_samples + num_window_samples/2, sample_to_frames
    if auxiliary_data:
        return np.hstack((S_subsampled, A))
    else:
        return S_subsampled


        


def get_edgemap_features(s,sample_rate,num_window_samples,
                          num_window_step_samples,fft_length,
                          freq_cutoff,kernel_length,
                           preemph=.95, quantile_level=.25):
    S = get_spectrogram_features(s,sample_rate,
                                 num_window_samples,
                                 num_window_step_samples,
                                 fft_length,
                                 freq_cutoff,kernel_length)
    E = _edge_map(S_subsampled,quantile_level)
    return E

def get_log_spectrogram(s,sample_rate,
                        num_window_samples,
                        num_window_step_samples,
                        fft_length,
                        preemph=.95,
                        return_freqs=False,
                        no_use_dpss=False):
    s = _preemphasis(s,preemph)
    S = _spectrograms(s,num_window_samples,
                      num_window_step_samples,
                      fft_length,
                      sample_rate,
                      no_use_dpss=no_use_dpss)
    freq_idx = np.arange(S.shape[1]) * (float(sample_rate)/fft_length)
    #S = S[:,:freq_idx]
    # correct for the shape
    # we want each row of S to correspond to a frequency
    # and we want the bottom row to represent the lowest
    # frequency
    if return_freqs:
        return np.log(S.transpose()), freq_idx
    else:
        return np.log(S.transpose())

def get_mel_spec(s,sample_rate,
                        num_window_samples,
                        num_window_step_samples,
                        fft_length,
                        preemph=.95,
                        freq_cutoff=None,
                 nbands = 40,
                 mel_smoothing_kernel=-1,
                 num_ceps=13,
                 lift=.6,
                 include_energy=False,
                 no_use_dpss=False,
                 time_smoothing_length=0):
    """
    The mel spectrogram, this is the basis for MFCCs
    Parameters:
    ===========
    num_ceps: int
        If mel_smoothing_kernel < 1 then we do cepstral
        smoothing and liftering to the mel spectrogram
        thus we get a spectral representation with
        somewhat nice properties than we would otherwise
        have
    lift: float
        This is the liftering factor if we do the cepstral
        smoothing and liftering of the mel spectral features
    """
    s = _preemphasis(s,preemph)
    S = _spectrograms(s,num_window_samples,
                      num_window_step_samples,
                      fft_length,
                      sample_rate,
                      no_use_dpss=no_use_dpss)
    freq_idx = np.arange(S.shape[1]) * (float(sample_rate)/fft_length)
    #S = S[:,:freq_idx]
    # correct for the shape
    # we want each row of S to correspond to a frequency
    # and we want the bottom row to represent the lowest
    # frequency

    energy = S.sum(1)
    S = S.transpose()
    if mel_smoothing_kernel < 1:
        # here we use cepstral smoothing
        S = audspec(S,sample_rate,nbands=nbands,
                       maxfreq=freq_cutoff)


        S = spec2cep(S,num_ceps=num_ceps)

        S = ceplifter(S,lift=.6)
        S = spec2cep(S,num_ceps=num_ceps,do_inv=True,inv_nrow=nbands)

        if include_energy:
            S = np.vstack((S,energy))
        return S
    else:
        M =audspec(S,sample_rate,nbands=nbands,
                       maxfreq=freq_cutoff)
        x = np.arange(0, mel_smoothing_kernel, 1, np.float64)
        x0 = mel_smoothing_kernel // 2.
        sigma = 1
        g=1/(sigma * np.sqrt(2*np.pi)) *np.exp(-((x-x0)**2  / 2* sigma**2))
        smoothing_kernel = g/g.sum()
        # feature smoothing should leave only meaningful features
        M_smoothed = convolve(M,smoothing_kernel.reshape(mel_smoothing_kernel,1),mode ='valid')
        # preserve time length of spectrogram, smooth over time
        M_smoothed = convolve(M_smoothed,smoothing_kernel.reshape(1,mel_smoothing_kernel),mode='same')
        if include_energy:
            M = np.vstack((M,energy))
        return M


def get_melfcc(s,sample_rate,
                        num_window_samples,
                        num_window_step_samples,
                        fft_length,
                        preemph=.95,
                        freq_cutoff=None,
                 nbands = 40,
                 num_ceps=13,
               lift=.6,
               include_energy=True,
               include_deltas=False,
               include_double_deltas=False,
               delta_window=9,
               no_use_dpss=False):
    """
    The mel spectrogram, this is the basis for MFCCs

    Translated from matlab in to python from this source
    http://labrosa.ee.columbia.edu/matlab/rastamat/melfcc.m

    Parameters:
    ==========
    include_energy: bool
        whether to correct the energy computation in the MFCCs
    include_deltas: bool
        whether to include the delta features

    """
    s = _preemphasis(s,preemph)
    S = _spectrograms(s,num_window_samples,
                      num_window_step_samples,
                      fft_length,
                      sample_rate,
                      no_use_dpss=no_use_dpss)
    freq_idx = np.arange(S.shape[1]) * (float(sample_rate)/fft_length)
    energy = S.sum(1)
    S = S.transpose()
    S = audspec(S,sample_rate,nbands=nbands,
                       maxfreq=freq_cutoff)
    S = spec2cep(S,num_ceps=num_ceps)
    S = ceplifter(S,lift=lift)
    # the log energy is non-sense right now
    # so we  replace that with a sensible log energy
    # this is copied from Dan ellis's implementation
    S[0,:] = energy[:]
    
    if not include_deltas:
        return S
    elif not include_double_deltas:
        delta_S = compute_deltas(S,delta_window=9)
        return S.vstack((S,delta_S))
    else:
        delta_S = compute_deltas(S,delta_window=9)
        delta_delta_S = compute_deltas(delta_S,delta_window=9)
        return np.vstack((S,delta_S,delta_delta_S))
    

def get_edgemap_no_threshold(s,sample_rate,
                             num_window_samples,
                             num_window_step_samples,
                             fft_length,
                             freq_cutoff,kernel_length,
                             preemph=.95,
                             use_mel = False,
                             return_S = False):

    if not use_mel:
        S = get_spectrogram_features(s,sample_rate,num_window_samples,
                          num_window_step_samples,fft_length,
                             freq_cutoff,kernel_length)
        # compute the edgemap
    else: # use mels
        s = _preemphasis(s,preemph)
        S = get_mel_spec(s,sample_rate,
                        num_window_samples,
                        num_window_step_samples,
                        fft_length,)
    if return_S:
        return _edge_map_no_threshold(S) + (S,)
    return _edge_map_no_threshold(S)

def threshold_edgemap(E,quantile_level,
                      edge_feature_row_breaks,
                      report_level=False,
                      abst_threshold=np.array([ 0.025,  0.025,  0.015,  0.015,  0.02 ,  0.02 ,  0.02 ,  0.02 ]),
                      critical_bands=None,
                      convert_to_binary=True):
    """
    Parameters:
    ===========
    E: numpy.ndarray[ndim=2]
        edge features
    quantile_level:
        quantile at which to threshold edges at zero
    edge_feature_row_beaks:
        indices that break the matrix into different edge types
    critical_bands: None or numpy.ndarray[ndim=2]
        dimension 0 is the number of critical bands, each row is a pair
        (critical_bands[i,0],critical_bands[i,1]) which says that the 
        ith critical band applied to exactly those frequencies f
        such that critical_bands[i,0] <= f < critical_bands[i,1] (approximately)
        assumption here is that critical_bands are a partition of a set the size of the chunks in edge_feature_row_breaks.
    """
    # see whether to report the level of the edge thresholds
    if report_level:
        if critical_bands is not None:
            edge_thresholds = np.empty((8,len(critical_bands)))
        else:
            edge_thresholds = np.empty(8)
    # allocate an empty array for the thresholded edges
    E_new = np.empty(E.shape)

    for edge_feat_idx in xrange(1,edge_feature_row_breaks.shape[0]):
        start_idx = edge_feature_row_breaks[edge_feat_idx-1]
        end_idx = edge_feature_row_breaks[edge_feat_idx]
        if critical_bands is not None:
            assert end_idx - start_idx == critical_bands[-1,-1]
        if report_level:
            if critical_bands is None:
                E_new[start_idx:end_idx,:],edge_thresholds[edge_feat_idx-1] = \
                    threshold_edge_block(E[start_idx:end_idx,:],quantile_level,report_level,
                                     abst_threshold[edge_feat_idx-1],
                                                 convert_to_binary=convert_to_binary)
            else:
                for cb_idx,cb in enumerate(critical_bands):
                    E_new[start_idx+cb[0]:
                              start_idx+cb[1],:], edge_thresholds[edge_feat_idx-1,
                                                                  cb_idx]= \
                        threshold_edge_block(E[start_idx+cb[0]:end_idx+cb[1],:],
                                             quantile_level,
                                             report_level,
                                             abst_threshold[edge_feat_idx-1],
                                                 convert_to_binary=convert_to_binary)
        else:
            if critical_bands is None:
                E_new[start_idx:end_idx,:] = \
                    threshold_edge_block(E[start_idx:end_idx,:],
                                         quantile_level,
                                         report_level,
                                         abst_threshold[edge_feat_idx-1],
                                                 convert_to_binary=convert_to_binary)
            else:
                for cb_idx,cb in enumerate(critical_bands):
                    E_new[start_idx+cb[0]:start_idx+cb[1],:] = \
                        threshold_edge_block(E[start_idx+cb[0]:end_idx+cb[1],:],
                                             quantile_level,
                                             report_level,
                                             abst_threshold[edge_feat_idx-1],
                                                 convert_to_binary=convert_to_binary)

            if convert_to_binary:
                assert np.max(E_new[start_idx:end_idx,:]) <= 1 and np.min(E_new[start_idx:end_idx]) >= 0 
    if report_level:
        return E_new, edge_thresholds




def threshold_edge_block(E_block,quantile_level,
                         report_level,
                         abst_threshold,
                         convert_to_binary=True):
    """
    Parameters:
    ===========
    E_block: numpy.ndarray[ndim=2]
        Blocks of the continuous edge amounts, these are all thresholded
        using sorting
    quantile_level: float
        Quantil level used to compute the thresholding value, represent
        the percentage of edges that are kept
    report_level: Bool
        Says whether the call of this function returns the value that
        thresholding has occurred at
    abst_threshold: float
        The lowest value that the quantile_level can threshold at.
    critical_bands: None or numpy.ndarray[ndim=2], Optional
        dimension 0 is the number of critical bands, each row is a pair
        (critical_bands[i,0],critical_bands[i,1]) which says that the 
        ith critical band applied to exactly those frequencies f
        such that critical_bands[i,0] <= f < critical_bands[i,1] (approximately)
    """
    # import pdb; pdb.set_trace()
    maxima_idx = E_block > 0
    maxima_vals = E_block[maxima_idx].ravel().copy()
    maxima_vals.sort()
    if maxima_vals.shape[0] <= 0:
        E_block[:] = 0
        return E_block

    tau_quant = maxima_vals[int(quantile_level*maxima_vals.shape[0])].copy()
    # zero out everything less than the quantile
    A = E_block[maxima_idx]
    # get the indices for the significant edges
    sig_idx = E_block[maxima_idx] >= max(tau_quant,abst_threshold)
    if np.any(-sig_idx):
        A[-sig_idx] = 0.
    if np.any(sig_idx) and convert_to_binary:
        A[sig_idx] =1
    E_block[maxima_idx] = A
    E_block[np.logical_not(maxima_idx)]=0
    if report_level:
        return E_block,tau_quant
    else:
        return E_block

def threshold_edge_block_heavy_hitter(E_block,hitter_level,
                         report_level,
                         abst_threshold,):
    """
    Parameters:
    ===========
    E_block: numpy.ndarray[ndim=2]
        Blocks of the continuous edge amounts, these are all thresholded
        using sorting
    quantile_level: float
        Quantil level used to compute the thresholding value, represent
        the percentage of edges that are kept
    report_level: Bool
        Says whether the call of this function returns the value that
        thresholding has occurred at
    abst_threshold: float
        The lowest value that the quantile_level can threshold at.
    critical_bands: None or numpy.ndarray[ndim=2], Optional
        dimension 0 is the number of critical bands, each row is a pair
        (critical_bands[i,0],critical_bands[i,1]) which says that the 
        ith critical band applied to exactly those frequencies f
        such that critical_bands[i,0] <= f < critical_bands[i,1] (approximately)
    """
    # import pdb; pdb.set_trace()
    
    maxima_idx = E_block > 0
    maxima_vals = E_block[maxima_idx].ravel().copy()
    maxima_vals.sort()
    if maxima_vals.shape[0] <= 0:
        E_block[:] = 0
        return E_block
    tau_quant = maxima_vals[int(quantile_level*maxima_vals.shape[0])].copy()
    # zero out everything less than the quantile
    A = E_block[maxima_idx]
    # get the indices for the significant edges
    sig_idx = E_block[maxima_idx] >= max(tau_quant,abst_threshold)
    if np.any(-sig_idx):
        A[-sig_idx] = 0.
    if np.any(sig_idx):
        A[sig_idx] =1
    E_block[maxima_idx] = A
    E_block[np.logical_not(maxima_idx)]=0
    if report_level:
        return E_block,tau_quant
    else:
        return E_block


def _compute_max_edges(Cand_max,Cmp1,Cmp2):
    """ Compute maximal edges and set the non-maximal edges
    to -inf
    """
    non_maxima_idx = np.logical_or(np.logical_or(np.logical_or(Cand_max<
                               Cmp1,
                               Cand_max<
                               Cmp2),
                                   np.logical_and(
            Cand_max == Cmp1,
            Cand_max == Cmp2)),
                                   Cand_max <= 0)
    Cand_max[non_maxima_idx]=0
    return Cand_max


def _compute_max_and_threshold(Cand_max,Cmp1,Cmp2,
                               quantile_level):
    non_maxima_idx = np.logical_or(np.logical_or(Cand_max<
                               Cmp1,
                               Cand_max<
                               Cmp2),
                                   np.logical_and(
            Cand_max == Cmp1,
            Cand_max == Cmp2))
    Cand_max[non_maxima_idx]=0.
    maxima_idx = np.logical_not(non_maxima_idx)
    # perform thresholding
    maxima_vals = Cand_max[maxima_idx].flat.copy()
    maxima_vals.sort()
    tau_quant = maxima_vals[int(quantile_level*maxima_vals.shape[0])].copy()
    # zero out everything less than the quantile
    A = Cand_max[maxima_idx]
    # get the indices for the significant edges
    sig_idx = Cand_max[maxima_idx] < tau_quant
    A[np.logical_not(sig_idx)] = 0.
    A[sig_idx] =1
    Cand_max[maxima_idx] = A
    return Cand_max

def spread_edgemap(T,edge_feature_row_breaks,edge_orientation,spread_length=3):
    for break_idx in xrange(1,edge_feature_row_breaks.shape[0]):
        start_idx = edge_feature_row_breaks[break_idx-1]
        end_idx = edge_feature_row_breaks[break_idx]
        T[start_idx:end_idx,:] = \
            _spread_edges(T[start_idx:end_idx],
                          edge_orientation[break_idx-1,:],
                          spread_length)

def _spread_edges(T,direction,spread_length):
    Z = np.zeros(T.shape+np.array((2*spread_length,2*spread_length)))
    Z[spread_length:-spread_length,spread_length:-spread_length] = T.copy()
    T_spread = np.zeros(T.shape)
    F_len = T.shape[0]
    T_len = T.shape[1]
    for k in xrange(-spread_length,spread_length+1):
        T_spread = np.maximum(T_spread,Z[spread_length+k*direction[0]:
                                             spread_length+F_len+k*direction[0],
                                         spread_length+k*direction[1]:
                                             spread_length+T_len+k*direction[1]])
    return T_spread


def _edge_map_no_threshold_old(S):
    """ function to do the edge processing
    somewhat complicated we have eight different directions
    for the edges to run
    consider the direction [1,0]

    indices range over [0,...,F-1],[0,...,T-1]
    in this case the entry
    E[0,0] = 0 if S[2,0] - S[1,0] < max(S[1,0]-S[0,0],
                                        S[3,0]-S[2,0])

    E[i,j] = 0 if S[i+2,j]-S[i+1,j] < max(S[i+1,j]-S[i,j],
d                                          S[i+2,j]-S[i+1,j])

    T_diff = T[1:,:]-T[:-1,:]
    T_bigger_left = (T_diff[1:-1,:]>T_diff[:-2,:])
    T_bigger_right = (T_diff[1:-1,:]>T_diff[2:,:])

    T_other_diff = -T_diff
    T_other_big_left = (T_other_diff[1:-1,:]-T_other_diff[:-2,:]) > 0.
    T_other
    S[2:-1,:] - S[1:-2,:]
    in the case [-1,0]
    E[0,0]=0 if S[1,0]-S[2,0] < max(S[0,0]-S[1,0],
                                    S[2,0]-S[3,0])

    E[i,j] = 0 if S[i+1,j]-S[i+2,j] < max(S[i,j]-S[i+1,j],
                                          S[i+1,j]-S[i+2,j])

    [0,1]
    E[i,j]
    """
    edge_feature_row_breaks = np.zeros(9)
    edge_orientations = np.zeros((8,2))
    # get [1,0] and [-1,0] features
    cur_E_idx = 0
    E = np.empty((8*S.shape[0]-6*3,S.shape[1]-3))
    T = S.copy()
    # cut down time
    T_diff = T[1:,1:-2] - T[:-1,1:-2]
    T_use = _compute_max_edges(T_diff[1:-1,:],
                         T_diff[:-2,:],
                         T_diff[2:,:])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    edge_orientations[0,0]=1
    edge_orientations[0,1]=0
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = -T[1:,1:-2] + T[:-1,1:-2]
    T_use = _compute_max_edges(T_diff[1:-1,:],
                         T_diff[:-2,:],
                         T_diff[2:,:])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    # keep track of where these edge features started
    edge_orientations[1,0]=-1
    edge_orientations[1,1]=0
    edge_feature_row_breaks[1] = cur_E_idx
    cur_E_idx = cur_E_idx + T_use.shape[0]
    # edge is [0,1]
    T_diff = T[:,1:]- T[:,:-1]
    T_use = _compute_max_edges(T_diff[:,1:-1],
                         T_diff[:,:-2],
                         T_diff[:,2:])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    edge_orientations[2,0]=0
    edge_orientations[2,1]=1
    edge_feature_row_breaks[2] = cur_E_idx
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = - T[:,1:] + T[:,:-1]
    T_use = _compute_max_edges(T_diff[:,1:-1],
                                       T_diff[:,:-2],
                                       T_diff[:,2:])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    edge_orientations[3,0]=0
    edge_orientations[3,1]=-1
    edge_feature_row_breaks[3] = cur_E_idx
    cur_E_idx = cur_E_idx + T_use.shape[0]
    # edge is [1,1]
    T_diff = T[1:,1:] - T[:-1,:-1]
    T_use = _compute_max_edges(T_diff[1:-1,1:-1],
                                       T_diff[:-2,:-2],
                                       T_diff[2:,2:])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    edge_orientations[4,0]=1
    edge_orientations[4,1]=1
    edge_feature_row_breaks[4] = cur_E_idx
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = - T[1:,1:] + T[:-1,:-1]
    T_use = _compute_max_edges(T_diff[1:-1,1:-1],
                               T_diff[:-2,:-2],
                               T_diff[2:,2:])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    edge_orientations[5,0]=-1
    edge_orientations[5,1]=-1
    edge_feature_row_breaks[5] = cur_E_idx
    cur_E_idx = cur_E_idx + T_use.shape[0]
    # edge [-1,1]
    T_diff = T[1:,:-1] - T[:-1,1:]
    T_use = _compute_max_edges(T_diff[1:-1,1:-1],
                               T_diff[:-2,2:],
                               T_diff[2:,:-2])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    edge_orientations[6,0]=1
    edge_orientations[6,1]=-1
    edge_feature_row_breaks[6] = cur_E_idx
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = - T[1:,:-1] + T[:-1,1:]
    T_use = _compute_max_edges(T_diff[1:-1,1:-1],
                                       T_diff[:-2,2:],
                                       T_diff[2:,:-2])
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_use.copy()
    edge_orientations[7,0]=-1
    edge_orientations[7,1]=1
    edge_feature_row_breaks[7] = cur_E_idx
    cur_E_idx = cur_E_idx + T_use.shape[0]
    edge_feature_row_breaks[8] = cur_E_idx
    return E,edge_feature_row_breaks, edge_orientations

def _edge_map_threshold_segments(E,block_length,
                                 spread_length,
                                 threshold=.7,
                                 edge_orientations = np.array([[ 1.,  0.],
                                    [-1.,  0.],
                                        [ 0.,  1.],
                                        [ 0., -1.],
                                        [ 1.,  1.],
                                        [-1., -1.],
                                        [ 1., -1.],
                                [-1.,  1.]]), 
                                 edge_feature_row_breaks = None,
                                 abst_threshold=np.array([ 0.025,  0.025,  0.015,
                                                           0.015,  0.02 ,  0.02 ,
                                                           0.02 ,  0.02 ]),
                                 verbose=False,
                                 critical_bands=None,
                                 return_thresholds=False,
                                 spread_type='unidirectional',
                                 convert_to_binary=True):
    """
    Parameters:
    ===========
    E:
        Raw edge intensities
    block_length:
        The length of the thresholded segments
    spread_length:
        radius for which the edge spreading is going to occur
    threshold:
        the quantile threshold for pulling all the coefficients down
    edge_orientations:
        the types of edges present
    edge_feature_row_breaks:
        the locations in the matrix that separate edge types
    critical_bands: None or numpy.ndarray[ndim=2]
        dimension 0 is the number of critical bands, each row is a pair
        (critical_bands[i,0],critical_bands[i,1]) which says that the 
        ith critical band applied to exactly those frequencies f
        such that critical_bands[i,0] <= f < critical_bands[i,1] (approximately)
    return_thresholds: bool, optional, default False
        Whether to return the absolute threshold or to suppress it
    
    """
    height,length = E.shape
    if edge_feature_row_breaks is None:
        base_height = (height - 6)/8
        assert base_height * 8 == height - 6
        edge_feature_row_breaks = \
            compute_edge_feature_row_breaks(base_height,
                                            edge_orientations)
    # then we are going to compute things
    num_full_blocks = length/block_length
    last_block_length = length % block_length

    if return_thresholds:
        view_thresholds = []
    
    if last_block_length > 0:
        last_E = E[:,-block_length:].copy()
        if verbose or return_thresholds:
            _, view_threshold= threshold_edgemap(last_E,
                                                 threshold,
                                                 edge_feature_row_breaks,
                                                 report_level=True,
                                                 abst_threshold=abst_threshold,
                                                 critical_bands=critical_bands,
                                                 convert_to_binary=convert_to_binary)
            if verbose:
                print view_threshold
            if return_thresholds:
                view_thresholds.append(view_threshold)
        else:
            threshold_edgemap(last_E,
                              threshold,
                              edge_feature_row_breaks,
                              report_level=False,
                              abst_threshold=abst_threshold,
                              critical_bands=critical_bands,
                              convert_to_binary=convert_to_binary)
        if spread_type=='unidirectional':
            if spread_length > 0:
                spread_edgemap(last_E,
                               edge_feature_row_breaks,
                               edge_orientations,
                               spread_length=spread_length)
        elif spread_type=='all':
            if spread_length > 0:
                for i in xrange(8):
                    start_idx=edge_feature_row_breaks[i]
                    if i >= len(edge_feature_row_breaks):
                        end_idx=len(edge_feature_row_breaks)
                    else:
                        end_idx=edge_feature_row_breaks[i+1]
                    last_E[start_idx:end_idx]=maximum_filter(
                        last_E[start_idx:end_idx],size=(2*spread_length+1,2*spread_length+1),mode='constant',cval=0)
        E[:,-last_block_length:] = last_E[:,-last_block_length:]

    for cur_block in xrange(num_full_blocks):
        E_block = E[:,cur_block*block_length:(1+cur_block)*block_length]
        if verbose or return_thresholds:
            _, view_threshold= threshold_edgemap(E_block,
                                                 threshold,
                                                 edge_feature_row_breaks,
                                                 report_level=True,
                                                 abst_threshold=abst_threshold,
                                                 critical_bands=critical_bands,
                                                 convert_to_binary=convert_to_binary)
            if verbose:
                print view_threshold
            if return_thresholds:
                view_thresholds.append(view_threshold)
        else:
            threshold_edgemap(E_block,
                              threshold,
                              edge_feature_row_breaks,
                              report_level=False,
                              abst_threshold=abst_threshold,
                              critical_bands=critical_bands,
                              convert_to_binary=convert_to_binary)

        if spread_type=='unidirectional':
            if spread_length > 0:
                spread_edgemap(E_block,
                               edge_feature_row_breaks,
                               edge_orientations,
                               spread_length=spread_length)
        elif spread_type=='all':
            if spread_length > 0:
                for i in xrange(8):
                    start_idx=edge_feature_row_breaks[i]
                    if i >= len(edge_feature_row_breaks):
                        end_idx=len(edge_feature_row_breaks)
                    else:
                        end_idx=edge_feature_row_breaks[i+1]
                    E_block[start_idx:end_idx]=maximum_filter(
                        E_block[start_idx:end_idx],size=(2*spread_length+1,2*spread_length+1),mode='constant',cval=0)
        if return_thresholds:
            return view_thresholds



def compute_edge_feature_row_breaks(base_height,
                                    edge_orientations):
    """
    Computes a presumed edge_feature_row_breaks vector
    on the basis of how tall most of the blocks should
    be minus those that don't compute vertical distances
    We assume that those that don't compute vertical distances
    will be three pixels taller than the other windows
    base_height is that height
    edge_orientations is a matrix whose rows are the direction the edges run
    """
    row_heights = np.zeros(9)
    row_heights[1:] += base_height * np.ones(8) + 3 * (edge_orientations[:,0] == 0)
    X = np.tile(np.arange(9),(9,1))
    return np.dot(row_heights, X>=X.T)



def _edge_map_no_threshold(S,
                           return_3_dimensions=False,
                           time_axis_0=False):
    """ function to do the edge processing
    somewhat complicated we have eight different directions
    for the edges to run
    consider the direction [1,0]

    indices range over [0,...,F-1],[0,...,T-1]
    in this case the entry
    E[0,0] = 0 if S[2,0] - S[1,0] < max(S[1,0]-S[0,0],
                                        S[3,0]-S[2,0])

    E[i,j] = 0 if S[i+2,j]-S[i+1,j] < max(S[i+1,j]-S[i,j],
d                                          S[i+2,j]-S[i+1,j])

    T_diff = T[1:,:]-T[:-1,:]
    T_bigger_left = (T_diff[1:-1,:]>T_diff[:-2,:])
    T_bigger_right = (T_diff[1:-1,:]>T_diff[2:,:])

    T_other_diff = -T_diff
    T_other_big_left = (T_other_diff[1:-1,:]-T_other_diff[:-2,:]) > 0.
    T_other
    S[2:-1,:] - S[1:-2,:]
    in the case [-1,0]
    E[0,0]=0 if S[1,0]-S[2,0] < max(S[0,0]-S[1,0],
                                    S[2,0]-S[3,0])

    E[i,j] = 0 if S[i+1,j]-S[i+2,j] < max(S[i,j]-S[i+1,j],
                                          S[i+1,j]-S[i+2,j])

    [0,1]
    E[i,j]
    """
    if time_axis_0:
        S = S.T
    edge_feature_row_breaks = np.zeros(9)
    edge_orientations = np.zeros((8,2))
    # get [1,0] and [-1,0] features
    cur_E_idx = 0
    # height variable
    H = S.shape[0]
    for i in xrange(8):
        edge_feature_row_breaks[i+1] = H*(i+1)
    E = np.zeros((8*H,S.shape[1]))
    T = S.copy()
    # cut down time
    T_diff = T[:,1:] - T[:,:-1]
    cand_max = T_diff > 0;
    if np.any(cand_max):
        E[:H,
           1:-2] = T_diff[:,1:-1] * ((T_diff[:,1:-1] >= T_diff[:,:-2]) *\
            (T_diff[:,1:-1] >= T_diff[:,2:]) *\
            (T_diff[:,1:-1] >= 0))
    edge_orientations[0,0]=0
    edge_orientations[0,1]=1
    # horizontal edges negative
    cand_max = T_diff < 0;
    if np.any(cand_max):
        E[H:2*H,
           1:-2] = -T_diff[:,1:-1] * ((T_diff[:,1:-1] <= T_diff[:,:-2]) *\
            (T_diff[:,1:-1] <= T_diff[:,2:]) *\
            (T_diff[:,1:-1] <= 0))
    edge_orientations[1,0]=0
    edge_orientations[1,1]=-1

    # Vertical Differences
    T_diff = T[1:,:] - T[:-1,:]
    cand_max = T_diff > 0;
    if np.any(cand_max):
        E[2*H+1:3*H-2,
           :] = T_diff[1:-1,:] * ((T_diff[1:-1,:] >= T_diff[:-2,:]) *\
            (T_diff[1:-1,:] >= T_diff[2:,:]) *\
            (T_diff[1:-1,:] >= 0))
    edge_orientations[2,0]=1
    edge_orientations[2,1]=0
    # negative vertical
    cand_max = T_diff < 0;
    if np.any(cand_max):
        E[3*H+1:4*H-2,
           :] = -T_diff[1:-1,:] * ((T_diff[1:-1,:] <= T_diff[:-2,:]) *\
            (T_diff[1:-1,:] <= T_diff[2:,:]) *\
            (T_diff[1:-1,:] <= 0))
    edge_orientations[3,0]=-1
    edge_orientations[3,1]=0

    # SW - NE differences
    T_diff = T[1:,1:] - T[:-1,:-1]
    cand_max = T_diff > 0;
    if np.any(cand_max):
        E[4*H+1:5*H-2,
           1:-2] = T_diff[1:-1,1:-1] * ((T_diff[1:-1,1:-1] >= T_diff[:-2,:-2]) *\
            (T_diff[1:-1,1:-1] >= T_diff[2:,2:]) *\
            (T_diff[1:-1,1:-1] >= 0))
    edge_orientations[4,0]=1
    edge_orientations[4,1]=1
    # negatives
    cand_max = T_diff < 0;
    if np.any(cand_max):
        E[5*H+1:6*H-2,
           1:-2] = -T_diff[1:-1,1:-1] * ((T_diff[1:-1,1:-1] <= T_diff[:-2,:-2]) *\
            (T_diff[1:-1,1:-1] <= T_diff[2:,2:]) *\
            (T_diff[1:-1,1:-1] <= 0))
    edge_orientations[5,0]=-1
    edge_orientations[5,1]=-1

    # SE - NW differences
    T_diff = T[:-1,1:] - T[1:,:-1]
    cand_max = T_diff > 0;
    if np.any(cand_max):
        E[6*H+1:7*H-2,
           1:-2] = T_diff[1:-1,1:-1] * ((T_diff[1:-1,1:-1] >= T_diff[2:,:-2]) *\
            (T_diff[1:-1,1:-1] >= T_diff[:-2,2:]) *\
            (T_diff[1:-1,1:-1] >= 0))
    edge_orientations[6,0]=-1
    edge_orientations[6,1]=1
    # negatives
    cand_max = T_diff < 0;
    if np.any(cand_max):
        E[7*H+1:8*H-2,
           1:-2] = -T_diff[1:-1,1:-1] * ((T_diff[1:-1,1:-1] <= T_diff[2:,:-2]) *\
            (T_diff[1:-1,1:-1] <= T_diff[:-2,2:]) *\
            (T_diff[1:-1,1:-1] <= 0))
    edge_orientations[7,0]=1
    edge_orientations[7,1]=-1
    if time_axis_0:
        if return_3_dimensions:
            E = np.array([E[i*H:(i+1)*H].T
                          for i in xrange(8)])
        else:
            E = E.T
    elif return_3_dimensions:
        E = np.array([E[i*H:(i+1)*H]
                      for i in xrange(8)])
    if time_axis_0:
        # TODO: have this work generally for all features
        # Possible TODO: develop with amitgroup code
        return E.T,edge_feature_row_breaks, edge_orientations
    else:
        return E,edge_feature_row_breaks, edge_orientations


def _edge_map(S,quantile_level,spread_length=3):
    """ function to do the edge processing
    somewhat complicated we have eight different directions
    for the edges to run
    consider the direction [1,0]

    indices range over [0,...,F-1],[0,...,T-1]
    in this case the entry
    E[0,0] = 0 if S[2,0] - S[1,0] < max(S[1,0]-S[0,0],
                                        S[3,0]-S[2,0])

    E[i,j] = 0 if S[i+2,j]-S[i+1,j] < max(S[i+1,j]-S[i,j],
d                                          S[i+2,j]-S[i+1,j])

    T_diff = T[1:,:]-T[:-1,:]
    T_bigger_left = (T_diff[1:-1,:]>T_diff[:-2,:])
    T_bigger_right = (T_diff[1:-1,:]>T_diff[2:,:])

    T_other_diff = -T_diff
    T_other_big_left = (T_other_diff[1:-1,:]-T_other_diff[:-2,:]) > 0.
    T_other
    S[2:-1,:] - S[1:-2,:]
    in the case [-1,0]
    E[0,0]=0 if S[1,0]-S[2,0] < max(S[0,0]-S[1,0],
                                    S[2,0]-S[3,0])

    E[i,j] = 0 if S[i+1,j]-S[i+2,j] < max(S[i,j]-S[i+1,j],
                                          S[i+1,j]-S[i+2,j])

    [0,1]
    E[i,j]
    """
    # get [1,0] and [-1,0] features
    cur_E_idx = 0
    E = np.empty((8*S.shape[0]-6*3,S.shape[1]-3))
    T = S.copy()
    # cut down time
    T_diff = T[1:,1:-2] - T[:-1,1:-2]
    T_use = _compute_max_and_threshold(T_diff[1:-1,:],
                                       T_diff[:-2,:],
                                       T_diff[2:,:],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(1,0))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = -T[1:,1:-2] + T[:-1,1:-2]
    T_use = _compute_max_and_threshold(T_diff[1:-1,:],
                                       T_diff[:-2,:],
                                       T_diff[2:,:],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(1,0))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    # edge is [0,1]
    T_diff = T[:,1:]- T[:,:-1]
    T_use = _compute_max_and_threshold(T_diff[:,1:-1],
                                       T_diff[:,:-2],
                                       T_diff[:,2:],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(0,1))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = - T[:,1:] + T[:,:-1]
    T_use = _compute_max_and_threshold(T_diff[:,1:-1],
                                       T_diff[:,:-2],
                                       T_diff[:,2:],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(0,1))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    # edge is [1,1]
    T_diff = T[1:,1:] - T[:-1,:-1]
    T_use = _compute_max_and_threshold(T_diff[1:-1,1:-1],
                                       T_diff[:-2,:-2],
                                       T_diff[2:,2:],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(1,1))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = - T[1:,1:] + T[:-1,:-1]
    T_use = _compute_max_and_threshold(T_diff[1:-1,1:-1],
                                       T_diff[:-2,:-2],
                                       T_diff[2:,2:],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(1,1))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    # edge [-1,1]
    T_diff = T[1:,:-1] - T[:-1,1:]
    T_use = _compute_max_and_threshold(T_diff[1:-1,1:-1],
                                       T_diff[:-2,2:],
                                       T_diff[2:,:-2],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(1,-1))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    T_diff = - T[1:,:-1] + T[:-1,1:]
    T_use = _compute_max_and_threshold(T_diff[1:-1,1:-1],
                                       T_diff[:-2,2:],
                                       T_diff[2:,:-2],
                                       quantile_level)
    T_spread = _spread_edges(T_use,(1,-1))
    E[cur_E_idx:cur_E_idx+T_use.shape[0],:] = T_spread.copy()
    cur_E_idx = cur_E_idx + T_use.shape[0]
    return E




def _get_edge_diffs(S):
    # edge [0,-1]
    top_bottom = S[:,:-1] - S[:,1:]

    # edge [0,1]
    bottom_top = -top_bottom
    # edge [-1,0]
    left_right = S[:-1,:] - S[1:,:]
    # edge [1,0]
    right_left = -left_right
    # edge [-1,-1]
    lefttop_rightbot = S[:-1,:-1] - S[1:,1:]
    # edge [1,1]
    rightbot_lefttop = - lefttop_rightbot
    # edge [1,-1]
    righttop_leftbot = S[1:,:-1] - S[:-1,1:]
    # edge [-1,1]
    leftbot_righttop=-righttop_leftbot




def _preemphasis(s,preemph=.95):
    return np.concatenate([[s[0]],
                           s[1:]- preemph*s[:-1]])


def make_gaussian_kernel(size,fwhm=3):
    """ Make a square gaussian kernel.

    size is the length of a side of the square
    fwhm is full-width-half-maximum, which
    can be thought of as an effective radius.

    code is (slightly) modified from:
    http://mail.scipy.org/pipermail/scipy-user/2006-June/008366.html
    """
    x = np.arange(0, size, 1, np.float64)
    y = x[:,np.newaxis]
    x0 = y0 = size // 2
    g=np.exp(-4*np.log(2) * ((x-x0)**2 + (y-y0)**2) / fwhm**2)
    return g/g.sum()


def _preemphasis_times(s,sr):
    return 1./sr * np.arange(len(s));

def _get_windows_signal(s,num_window_samples,num_window_step_samples):
    # we have the property that we have windows with indices
    # 0 ... last_win_idx
    # the sample index for the first entry of window last_win_idx
    # will be last_win_idx*num_window_step_samples
    # so its the largest integer such that
    # last_win_idx*num_window_step_samples + num_window_samples -1 <= len(s)-1
    # division computes floor implicitly
    last_win_idx = (len(s)-num_window_samples)/num_window_step_samples
    num_windows = last_win_idx + 1
    window_idx = (np.tile(np.arange(num_window_samples),
                    (num_windows,1))\
                    + num_window_step_samples\
                    *np.arange(num_windows).reshape((num_windows,1))).ravel()
    return s[window_idx].reshape(num_windows,num_window_samples)



def _get_windows(s,num_window_samples,num_window_step_samples):
    # we have the property that we have windows with indices
    # 0 ... last_win_idx
    # the sample index for the first entry of window last_win_idx
    # will be last_win_idx*num_window_step_samples
    # so its the largest integer such that
    # last_win_idx*num_window_step_samples + num_window_samples -1 <= len(s)-1
    # division computes floor implicitly
    last_win_idx = (len(s)-num_window_samples)/num_window_step_samples
    num_windows = last_win_idx + 1
    window_idx = np.arange(num_window_samples)
    return np.tile(np.arange(num_window_samples),
                    (num_windows,1))\
                    + num_window_step_samples\
                    *np.arange(num_windows).reshape((num_windows,1))

def _get_windows_sample_stats(s,num_window_samples,num_window_step_samples):
    # compute the average sample index for each window
    # this allows us to associate a time to each entry of the spectrogram
    num_windows = (len(s)-num_window_samples)/num_window_step_samples+1
    first_window_s_avg = (num_window_samples-1)/2.
    window_s_avg_step = num_window_step_samples
    return first_window_s_avg, window_s_avg_step, num_windows

def _get_smoothed_sample_avg(window_avgs,kernel_length):
    start_smoothed = (window_avgs[0] + window_avgs[kernel_length-1])/2.
    end_smoothed = (window_avgs[-1]+window_avgs[-kernel_length])/2.
    win_diffs = window_avgs[1] - window_avgs[0]
    return np.arange(start_smoothed,end_smoothed+.1,win_diffs)

def _get_edge_sample_stats(feature_start,feature_step, num_features):
    # we ignore the first and last because we only look
    # at maxima for edges that stretch along time
    # we also consider the time in between two edges as the location of the edge
    # 3/2, 5/2, ... ,num_features-5/2
    # 0, 1, ... , num_edge_features-1
    # num_edge_features  = num_features - 5/2 -3/2 +1
    return feature_start + 3./2 * feature_step,\
        feature_step,\
        num_features


def _get_labels(label_times,
                labels,
                feature_start, feature_step, num_features,
                sr):
    # label_start_times and labels should have the same length feature
    # samples is an array of what sample each feature in a spectrogram
    # or edgegram corresponds to
    # label_start_times are the absolute times when features start
    # labels are the labels themselves, we will construct an array the same size as feature_samples but whose entries are the label_start_times
    # sr is the sampling rate
    label_transitions = sr * label_times
    feature_labels = np.empty(num_features,
                              dtype=labels.dtype)
    end_idx = -1
    # make sure that we start where the label_transition
    # surrounds the feature starting index
    label_time_start_idx = 0
    while label_transitions[label_time_start_idx,1] <= feature_start:
        label_time_start_idx +=1
    # initialize array that keeps track of when transitions
    # in the labels happen
    feature_label_transitions = -np.int_(np.ones(label_times.shape[0]+1))
    for ls_time_idx in xrange(label_time_start_idx,label_times.shape[0]):
        # find smallest k such that
        #    label_transitions[ls_time_idx,0] <= feature_start
        #          + k * feature_step
        start_idx = end_idx+1
        # find largest k such that
        #    label_transitions[ls_time_idx,1] > feature_start
        #          + k * feature_step
        end_idx = min(int(np.floor((label_transitions[ls_time_idx,1] -\
            feature_start)/feature_step)),num_features-1)
        feature_labels[start_idx:end_idx+1] =labels[ls_time_idx]
        feature_label_transitions[ls_time_idx] = np.int(start_idx)
    feature_label_transitions[-1] = num_features
    return feature_labels, feature_label_transitions





def _spectrograms_old(s,num_window_samples,
                  num_window_step_samples,
                  fft_length,
                  sample_rate):
    # pre-emphasis
    s=_preemphasis(s)
    windows = _get_windows(s,num_window_samples,num_window_step_samples)
    swindows = np.vectorize(lambda i: s[i])(windows)
    return np.abs(fft(hanning(num_window_samples) * swindows,fft_length)[:,:fft_length/2+1])

def _spectrograms(s,num_window_samples,
                  num_window_step_samples,
                  fft_length,
                  sample_rate,
                  K=5,
                  no_use_dpss=False,
                  auxiliary_data=False,
                  return_frame_to_sample_mapping=False):
    """
    Gives the discrete prolate slepian sequence
    estimation of the power spectrum

    K parameter is the number of slepian sequences to use
    """
    num_windows = int(.5 + (len(s)-num_window_samples)/float(num_window_step_samples))
    Slep = np.zeros((num_windows,
                     fft_length/2))
    if auxiliary_data:
        zero_crossings_energy_wiener = np.zeros((num_windows,3))
    H = np.hamming(num_window_samples)
    t = float(num_window_samples)
    for win_id in xrange(num_windows):
        if no_use_dpss:
            Slep[win_id] = np.abs(fft( H * s[win_id*num_window_step_samples:win_id*num_window_step_samples+num_window_samples],fft_length)[:fft_length/2])**2
        else:
            signal = s[win_id*num_window_step_samples:win_id*num_window_step_samples+num_window_samples]
            if auxiliary_data:
                zero_crossings_energy_wiener[win_id,0] = np.sum(signal[:-1]*signal[1:] > 0)/t
                zero_crossings_energy_wiener[win_id,1] = np.log(np.var(signal))
            if num_window_samples == 320:
                J = fft(E_slep[:5] * signal,fft_length)
            elif num_window_samples == 160:
                J = fft(E_slep160[:5] * signal,fft_length)
            J=J[:,:fft_length/2]
            Slep[win_id] = (np.abs(J)**2).sum(0)/5
            if auxiliary_data:
                zero_crossings_energy_wiener[win_id,2] = np.exp(np.mean(np.log(Slep[win_id])))/np.mean(Slep[win_id])
            
    if auxiliary_data:
        return Slep, zero_crossings_energy_wiener
    elif return_frame_to_sample_mapping: 
        return Slep, lambda t: np.arange(max(int(int(float(t-num_window_samples)/num_window_step_samples+1)),0),min(int(t/num_window_step_samples)+1,len(Slep)))
    else:
        return Slep

def wiener_entropy_pyramid(S,num_levels=3,level_factor=3):
    """
    Compute the wiener entropy
    Parameters:
    ===========
    S:
       assumed to have frequency dimension as dimension 1
       and time as dimension 0
    """
    logS = np.log(S)
    return np.exp(np.mean(np.log(S),1)) / np.mean(S)

def construct_pyramid(S,num_levels,level_factor):
    out_S = np.zeros((S.shape[0],0),dtype=S.dtype)
    
    for cur_level in xrange(num_levels-1,-1,-1):
        num_channels = level_factor**(cur_level)
        for channel_id in xrange(num_channels):
            if channel_id ==0:
                out_S = out_S.hstack((out_S,
                                  S[:,channel_id::num_channels]))
            else:
                out_S[-num_channels:] += S[:,channel_id::num_channels]

    return out_S

def zero_crossing_rates(s,num_window_samples,
                       num_window_step_samples,
                       fft_length,
                       sample_rate,
                       K=5,
                       no_use_dpss=False):
    """
    Computes the zero crossing rate for the overall signal
    and for the signal filtered at various frequencies
    using bandpass filters
    """
    zero_crossings = np.zeros(len(s)-num_window_samples-num_window_step-samples + (len(s) % num_window_step_samples))
    zero_crossings[:len(s)-1] = s[:-1]*s[1:]
    zero_crossing = zero_crossing.reshape(len(zero_crossing)/num_window_step_samples,
                                          num_window_step_samples)
    zero_crossings = zero_crossings.sum(1)
    


def audspec(spectrogram,sample_rate,nbands=None,
            minfreq=0,maxfreq=None,
            sumpower=1,bwidth=1.0,return_bins=False):
    """
    Copied from http://labrosa.ee.columbia.edu/matlab/rastamat/audspec.m
    sample_rate should be an integer
    """
    if nbands is None:
        nbands = int(np.ceil(hz2bark(sample_rate/2)+1))
    if maxfreq is None:
        maxfreq = sample_rate/2
    nfreqs, nframes = spectrogram.shape
    nfft = (nfreqs-1)*2
    # only implementing the mel case
    wts,_ = fft2melmx(nfft,sample_rate,nbands,bwidth,
                    minfreq,maxfreq)
    wts = wts[:, :nfreqs]

    if return_bins:
        return np.log(np.dot(wts, spectrogram)), _
    else:
        return np.log(np.dot(wts, spectrogram))

def ceplifter(ceps,lift = .6):
    """
    Copied from Dan Ellis 
    http://labrosa.ee.columbia.edu/matlab/rastamat/lifter.m
    

    We assume lift \in (0,10]
    
    Parameters:
    ===========
    ceps: np.ndarray[ndim=2]
        These are the cepstral coefficients to be liftered. The 0
        dimension is assumed to be the coefficients and dimension
        1 is assumed to be time
    lift: float
        Liftering constant
    """
    
    return np.dot(np.diag(np.hstack((1.,
                              np.arange(1.,ceps.shape[0])**lift))),
                  ceps)
    

def spec2cep(log_spectrogram,num_ceps=13,do_inv=False,inv_nrow=40):
    """
    Computes the cepstrum

    Copied from Dan Ellis http://labrosa.ee.columbia.edu/matlab/rastamat/spec2cep.m
    to mimic his defaults
    
    Parameters:
    ===========
    log_spectrogram: np.ndarray[ndim=2]
        Should be nfilts by ntime, the default
        expectation is that nfilts = 40 so there
        are 40 bands and then we have a matrix that we can
        multiply that by in order to get the MFCCs
    num_cep: int
        Number of cepstral coefficients to keep
    do_inv: bool
        Whether to perform the inverse transformation, this is useful
        for doing cepstral liftering/smoothing
    
    """
    nrow = log_spectrogram.shape[0]
    if nrow != 40 and not do_inv: # we saved a matrix for the 40 case
        dctm = np.cos(np.dot(np.diag(np.arange(num_ceps,dtype=np.float)),np.tile(np.arange(1.,2*nrow,2)/(2*nrow)*np.pi,(num_ceps,1)))) * np.sqrt(2./nrow)
        dctm[0,:] /= np.sqrt(2.)
    elif inv_nrow != 40 and do_inv:
        dctm = np.cos(np.dot(np.diag(np.arange(num_ceps,dtype=np.float)),np.tile(np.arange(1.,2*inv_nrow,2)/(2*inv_nrow)*np.pi,(num_ceps,1)))) * np.sqrt(2./inv_nrow)
        dctm[0,:] /= np.sqrt(2.)
    else:
        dctm = dctm13_40
        
    if do_inv:
        return  np.dot(dctm.T,log_spectrogram)
    else:
        return  np.dot(dctm,log_spectrogram)

def compute_deltas(S,delta_window=9):
    """
    Functionality Copied from 
    http://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/deltas.m
    which was in turn written to mimic 
    feacalc

    We use a window of length delta_window to compute a time derivative
    for the features, time derivative corresponds to the regression
    coefficient taken over a window. We use the first or last elements
    repeated
    
    Parameters:
    ===========
    S: np.ndarray[ndim=2]
        Spectrogram, frequency or quefrency is supposed to be along the 
        0-th axis while time is along the  1st axis.
    delta_window: int
        Converted to float for computational purposes: this is the 
        length of the window used to compute the derivative.
    
    """
    delta_window = float(delta_window)


    t_vec = np.arange(delta_window,dtype=float)
    sum_vec = np.ones(delta_window,dtype=float)
    t_sum = t_vec.sum()

    denom = delta_window * np.sum(t_vec**2) - t_vec.sum()**2

    A = ( delta_window * correlate1d(S,t_vec,axis=-1,mode='nearest') - correlate1d(S,sum_vec,axis=-1,mode='nearest')*t_sum)/denom
    return A

    

def fft2melmx(nfft,sample_rate,nfilts=40,width=1.0,minfrq=0,
              maxfrq=None):
    """
    Copied nearly directly from Dan Ellis' code:
    http://labrosa.ee.columbia.edu/matlab/rastamat/fft2melmx.m

    Parameters:
    ===========
    nfft: int
        number of samples for the fourier transform
    sr: int
        number of samples per second

    Complete, matches with Dan Ellis' implementation
    """
    if maxfrq is None:
        maxfrq = sample_rate/2
    wts = np.zeros((nfilts,nfft))
    # center frequencies for the mel bins
    fftfrqs = np.arange(nfft)/np.float64(nfft)*sample_rate
    minmel = hz2mel_num(minfrq)
    maxmel = hz2mel_num(maxfrq)
    binmels = np.arange(minmel,maxmel+1,(maxmel-minmel)/(nfilts+1))
    binfrqs = np.array(map(mel2hz,
                           binmels))
    binbin = np.array(map(round,binfrqs/sample_rate*(nfft-1)))
    for filt in xrange(nfilts):
        fs = binfrqs[filt:filt+3].copy()
        fs = fs[1] + width * (fs - fs[1])
        loslope = (fftfrqs - fs[0])/(fs[1] - fs[0])
        hislope = (fs[2] - fftfrqs)/(fs[2] - fs[1])
        wts[filt,:] = np.maximum(0,
                              np.minimum(loslope,
                                         hislope))
    wts = np.dot(np.diag(2./(binfrqs[2+np.arange(nfilts)]-binfrqs[:nfilts])),wts)
    wts[:,(nfft/2+1):nfft+1]=0.
    return wts, binfrqs



def mel2hz(mel):
    f_0 = 0; # 133.33333;
    f_sp = 200./3; # 66.66667;
    brkfrq = 1000;
    # starting mel value for log region
    brkpt  = (brkfrq - f_0)/f_sp;
    if mel > brkpt:
        # log(exp(log(6.4)/27))
        # magic log step number
        logstep = 0.068751777420949123
        return brkfrq*np.exp(logstep*(mel-brkpt))
    else:
        return f_0 + f_sp*mel



def hz2mel_num(freq):
    """
    Copied from Dan Ellis' code
    http://labrosa.ee.columbia.edu/matlab/rastamat/hz2mel.m

    Completed
    """
    f_0 = 0.
    f_sp = 200/3.
    brkfrq = 1000.
    if  freq < brkfrq:
        return (freq - f_0)/f_sp
    else:
        brkpt = (brkfrq - f_0)/f_sp
        step = 0.068751777420949123 # np.log(6.4)/27
        return brkpt + np.log(freq/brkfrq)/step


def htk_hz2mel(freq):
    """
    Copied from Dan Ellis' code
    http://labrosa.ee.columbia.edu/matlab/rastamat/hz2mel.m
    Based on the mel frequency bin computations from the htk kit
    """
    return 2595. * np.log10(1+freq/700.)

def hz2bark(freq):
    return 6. * np.arcsinh(freq/600.)

def _mel_filter_freq():

    pass


def edge_map_times(N, window_length, hop_length,
                   kernel_length):
    """Returns a vector of times, each entry corresponds to
    frame in the edge map features, the entry value is the
    time in the signal that these features are considered
    to occur.  This is used in the process of labeling
    the phonetic class that particular edge map features
    are associated with

    The assumption is that the signal is uniformly sampled.
    The times returned will sometimes occur within a sample

    Parameters
    ----------
    N: int
       Number of samples in the signal

    window_length:
       Number of samples in a given window

    hop_length:
       Number of samples we jump over in a hop

    kernel_length:
       Number of samples that we take the kernel over

    """
    # compute the number of windows
    num_windows = (N-window_length)/hop_length+1
    window_points = window_length/2. \
        + hop_length * np.arange(num_windows)

    # correct for kernel length
    window_points = window_points[kernel_length/2:\
                                      end-kernel_length/2]

    window_points = window_points[1:end-1]



def labels_for_edgemaps(T, sr, label_times, labels,
                        window_length, hop_length,
                        kernel_length):

    """Returns the the labels for the edge map computation on
    a digital signal. The labels are given as start times for
    when a given sound begins

    Parameters
    ----------
    T: int
        number of samples in signal
    sr: int
        samples per second
    label_times: array
        N-dimensional array of floats, each time should be
        less than T/sr
    labels: ndarray
        labels can be any datatype, should be the same length
        as label_times
    window_length: int
        number of samples in a window
    hop_length: int
        number of samples between successive windows
    kernel_length: int
        number of frames used in the smoothing kernel

    Returns
    -------
    edge_map_labels: array
        array of the labels, the length of the array
        corresponds to the length of the edge map features
    edge_map_transitions: ndarray
        an N-dimensional array of integers where the integers
        correspond to when the next label starts and N is
        the number of labels
    """
    start_sample, num_windows = _get_start_samples(T,
                                                   window_length,
                                                   hop_length,
                                                   kernel_length)
    # correct for where maxima can occur
    start_sample += hop_length
    # maxima can only occur in the middle windows
    num_windows = num_windows - 2
    # convert to label times to sample indices
    edge_map_transitions = np.ceil(sr * label_times)
    edge_map_labels = np.empty([num_windows],dtype=labels.dtype)
    # we find all the samples that for a given t are such
    # that they are in the half-open interval
    #  \[edge_map_transitions[t],
    #    edge_map_transitions[t+1] \)
    cur_map = 0
    for t in range(label_times.size-1):
        num_edge_maps = (edge_map_transitions[t+1] \
                       - edge_map_transitions[t] ) \
                       / hop_length
        edge_map_labels[cur_map:cur_map+num_edge_maps] \
            = labels[t]
        cur_map=cur_map+num_edge_maps
    edge_map_labels[cur_map:-1]=labels[-1]
    return edge_map_labels, edge_map_transitions

def _get_start_samples(T,window_length,hop_length,kernel_length):
    """
    Returns the start and end window sample indices for the
    frames in the short time fourier transform after
    smoothing with a kernel over kernel_length frames

    Parameters
    ----------
    T: int
        number of samples in the signal
    window_length: int
        number of samples in a window
    hop_length: int
        number of samples between successive windows
    kernel_length: int
        number of windows used by the smoothing kernel

    Returns
    -------
    start_sample: double
        sample index for the middle sample of the first
        window (possibly not an integer)
    num_windows: int
        total number of windows

    """
    # the kernel_length/2 +1 takes care of the boundary
    # windows lost to smoothing
    start_window = kernel_length/2+1
    # the -2 takes care of the fact we lose one window
    #  at the end for edges across time
    end_window = (T-window_length)/hop_length \
        - kernel_length/2 -2
    num_windows = end_window - start_window + 1
    # want the exact middle of window
    window_middle = (window_length-1)/2.
    start_sample = start_window*hop_length + window_middle
    return start_sample, num_windows
